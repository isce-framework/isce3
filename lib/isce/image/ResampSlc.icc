//-*- C++ -*-
//-*- coding: utf-8 -*-

#if !defined(ISCE_IMAGE_RESAMPSLC_ICC)
#error "ResampSlc.icc is an implementation detail of class ResampSlc"
#endif

// Since fmod(a,b) in C++ != MODULO(a,b) in Fortran for all a,b, define a C++ equivalent
#define modulo_f(a,b) fmod(fmod(a,b)+(b),(b))

// Default constructor (assumes zero-Doppler imaging and no flattening)
isce::image::ResampSlc::
ResampSlc() : _haveRefMode(false) {
    // Make a default LUT (zero-doppler)
    isce::core::LUT1d<double> zerodop;
    _dopplerLUT = zerodop;
    // Create an empty ImageMode
    isce::product::ImageMode mode;
    _mode = mode;
}

// Constructor from an isce::product::Product
isce::image::ResampSlc::
ResampSlc(const isce::product::Product & product) : _haveRefMode(false) {
    // Cache the instrument
    isce::radar::Radar instrument = product.metadata().instrument();
    // Set the doppler
    _dopplerLUT = instrument.contentDoppler();
    // Set the image mode
    _mode = product.complexImagery().primaryMode();
    // Save the filename
    _filename = product.filename();
}

// Constructor from isce::core::LUT1d<double> and isce::product::ImageMode
isce::image::ResampSlc::
ResampSlc(const isce::core::LUT1d<double> & doppler, const isce::product::ImageMode & mode) :
    _dopplerLUT(doppler), _mode(mode), _haveRefMode(false) {
    // _filename variable set to empty string since it shouldn't be used with
    // a non-HDF5 constructor
    _filename = " ";
}

// Constructor from isce::core objects
isce::image::ResampSlc::
ResampSlc(const isce::core::LUT1d<double> & doppler, const isce::core::Metadata & meta) :
    _dopplerLUT(doppler), _mode(meta) {
    // _filename variable set to empty string since it shouldn't be used with
    // a non-HDF5 constructor
    _filename = " ";
}

// Destructor
isce::image::ResampSlc::
~ResampSlc() {}

// Get range carrier polynomial
isce::core::Poly2d
isce::image::ResampSlc::
rgCarrier() const {
    return _rgCarrier;
}

// Set range carrier polynomial
void isce::image::ResampSlc::
rgCarrier(isce::core::Poly2d & lut) {
    _rgCarrier = lut;
}

// Get azimuth carrier polynomial
isce::core::Poly2d
isce::image::ResampSlc::
azCarrier() const {
    return _azCarrier;
}

// Set azimuth carrier polynomial
void isce::image::ResampSlc::
azCarrier(isce::core::Poly2d & lut) {
    _azCarrier = lut;
}

// Get Doppler LUT
isce::core::LUT1d<double>
isce::image::ResampSlc::
doppler() const {
    return _dopplerLUT;
}

// Set Doppler LUT
void isce::image::ResampSlc::
doppler(isce::core::LUT1d<double> & lut) {
    _dopplerLUT = lut;
}

// Set reference product
void isce::image::ResampSlc::
referenceProduct(const isce::product::Product & refProduct) {
    // Extract the reference image mode
    _refMode = refProduct.complexImagery().primaryMode();
    // Indicate we have a reference mode
    _haveRefMode = true;
}

// Get image mode
isce::product::ImageMode
isce::image::ResampSlc::
imageMode() const {
    return _mode;
}

// Set imageMode from copy
void isce::image::ResampSlc::
imageMode(const isce::product::ImageMode & mode) {
    _mode = mode;
}

// Get reference imageMode
isce::product::ImageMode
isce::image::ResampSlc::
refImageMode() const {
    return _refMode;
}

// Set reference imageMode from copy
void isce::image::ResampSlc::
refImageMode(const isce::product::ImageMode & mode) {
    _refMode = mode;
}

// Announce my properties to the world
void isce::image::ResampSlc::
declare(int inLength, int inWidth,
    int outLength, int outWidth) const {
    // Make info channel
    pyre::journal::info_t channel("isce.core.ResampSlc");
    // Basic info
    channel << pyre::journal::newline
            << "Resample one image to another image coordinates >>"
            << pyre::journal::newline << pyre::journal::newline;
    channel << "Input Image Dimensions:  " << inLength << " lines, "
            << inWidth << " pixels" 
            << pyre::journal::newline;
    channel << "Output Image Dimensions: " << outLength << " lines, "
            << outWidth << " pixels"
            << pyre::journal::newline << pyre::journal::newline;
    //channel << "Number of threads: " << omp_get_max_threads() << pyre::journal::newline;
    channel << "Complex data interpolation" << pyre::journal::newline;
}

// Get the number of lines per tile
size_t isce::image::ResampSlc::
linesPerTile() const {
    return _linesPerTile;
}

// Set the number of lines per tile
void isce::image::ResampSlc::
linesPerTile(size_t value) {
    _linesPerTile = value;
}

// Compute number of tiles given a specified nominal tile size
int isce::image::ResampSlc::
_computeNumberOfTiles(int outLength, int linesPerTile) {
    // Compute floor(nTiles)
    int nTiles = outLength / linesPerTile;
    // See if there are any leftover lines to add an extra tile
    int extraLines = outLength - nTiles * linesPerTile;
    if (extraLines > 0) {
        nTiles += 1;
    }
    return nTiles;
}

// Prepare interpolation pointer
void isce::image::ResampSlc::
_prepareInterpMethods(isce::core::dataInterpMethod method, int sinc_len) {
    _interp = new isce::core::Sinc2dInterpolator<std::complex<float>>(
                  sinc_len, isce::core::SINC_SUB);
}

// end of file
