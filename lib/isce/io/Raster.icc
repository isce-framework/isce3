//-*- C++ -*-
//-*- coding: utf-8 -*-
//
// Author: Marco Lavalle
// Original code: Joshua Cohen
// Copyright 2018
//

#if !defined(ISCE_IO_RASTER_ICC)
#error "Raster.icc is an implementation detail of class Raster"
#endif



// Construct a Raster object referring to new file assuming default GDAL driver, type and band.
template<typename T>
isce::io::Raster::Raster(const std::string & fname,       // filename of new file to be created
			   const std::vector<T> & buffer,   // buffer used to infer width and type
			   size_t length) :                 // length of raster
  isce::io::Raster(fname, buffer.size(), length, 1, GDT.at(typeid(T))) {}



// Construct a Raster object referring to new file assuming default GDAL driver, type and band.
template<typename T>
isce::io::Raster::Raster(const std::string & fname,       // filename of new file to be created
			   const std::valarray<T> & buffer, // buffer used to infer width and type
			   size_t length) :                 // length of raster
  isce::io::Raster(fname, buffer.size(), length, 1, GDT.at(typeid(T))) {}



// Copy constructor
inline isce::io::Raster& isce::io::Raster::operator=(const Raster &rhs) {
  dataset( rhs._dataset );      // weak-copy pointer
  dataset()->Reference();       // increment GDALDataset reference counter
  return *this;
}



/**
 * @param[in] fname Filename to open
 * @param[in] access Access mode*/
inline void isce::io::Raster::open(const std::string &fname,
			      GDALAccess access=GA_ReadOnly) {
  GDALClose( _dataset );
  dataset( static_cast<GDALDataset*>(GDALOpenShared( fname.c_str(), access )) );
}



/** 
 * @param[in] rast Input raster dataset*/
inline void isce::io::Raster::addRasterToVRT(const isce::io::Raster& rast) {
  if ( match(rast) )                                      // if rasters have the same size
    for ( size_t b=1; b<=rast.numBands(); ++b )           // for each band in input Raster
      addBandToVRT( rast.dataset()->GetRasterBand(b) );   // add GDALRasterBand to VRT
  else
    throw std::length_error("In isce::io::Raster::Raster() - Rasters have different sizes.");
}



/** 
 * @param[in] inBand GDALRasterBand pointer */
inline void isce::io::Raster::addBandToVRT(GDALRasterBand * inBand) {
  if ( !strcmp(dataset()->GetDriverName(), "VRT") ) {                   // dataset is VRT
    dataset()->AddBand( inBand->GetRasterDataType(), NULL );            // add band to VRT dataset
    GDALRasterBand *rastBand = dataset()->GetRasterBand( numBands() );  // get last band
    VRTAddSimpleSource(rastBand,
		       inBand,
		       0, 0,
		       inBand->GetXSize(), inBand->GetYSize(), 
		       0, 0,
		       inBand->GetXSize(), inBand->GetYSize(),
		       NULL, VRT_NODATA_UNSET);
  }
    else
      throw std::length_error("In isce::io::Raster::AddBandToVRT() - GDAL driver must be VRT.");
}



/**
 * @param[in] fname Raw file name
 * @param[in] dtype GDALDataType */
inline void isce::io::Raster::addRawBandToVRT(const std::string &fname, GDALDataType dtype) {
  if ( !strcmp(dataset()->GetDriverName(), "VRT") ) { 
    char** papszOptions = NULL;
    std::string srcName = fname.substr(0, fname.find_last_of("."));
    papszOptions = CSLAddNameValue(papszOptions, "subclass", "VRTRawRasterBand");
    papszOptions = CSLAddNameValue(papszOptions, "SourceFilename", srcName.c_str()); 
    papszOptions = CSLAddNameValue(papszOptions, "RelativeToVRT", "true");
    dataset()->AddBand(dtype, papszOptions);
    CSLDestroy(papszOptions); 
  }
    else
      throw std::length_error("In isce::io::Raster::AddBandToVRT() - GDAL driver must be VRT.");
}




/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 *                                          PIXEL OPERATIONS
 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 */
/**
 * @param[inout] buffer Buffer of type T
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] band Band index (1-based)
 * @param[in] GDALRWFlag
 *
 * Determines datatype translation to use from the type of buffer passed in*/
template<typename T>
void isce::io::Raster::getSetValue(T & buffer,           // i/o buffer of type T
				     size_t xidx,          // 0-indexed line within band
				     size_t yidx,          // 0-indexed column within band
				     size_t band,          // 1-indexed band number
				     GDALRWFlag iodir) {   // i/o direction (GF_Read or GF_Write) 

  if ( GDT.count(typeid(T)) ) { // buffer type is supported by GDAL
    auto iostat = _dataset->GetRasterBand(band)->RasterIO(iodir, xidx, yidx, 1, 1, &buffer,
							  1, 1, GDT.at(typeid(T)), 0, 0);

    if ( iostat != CPLE_None ) // RasterIO returned error
      std::cout << "In isce::io::Raster::getSetValue() - error in RasterIO." << std::endl;
  }
  else
    std::cout << "In isce::io::Raster::get/setValue() - Buffer datatype " << typeid(T).name() <<
      " is not mappable to a GDALDataType." << std::endl;
}



/**
 * @param[out] buffer Buffer to copy data into
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] band Band index (1-based)*/
template<typename T>
void isce::io::Raster::getValue(T &buffer, size_t xidx, size_t yidx, size_t band) {
  getSetValue(buffer, xidx, yidx, band, GF_Read);
}


/**
 * @param[out] buffer Buffer to copy data into
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)*/
template<typename T>
void isce::io::Raster::getValue(T &buffer, size_t xidx, size_t yidx) {
  getValue(buffer, xidx, yidx, 1);
}



/**
 * @param[in] buffer Buffer to copy data from
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] band Band index (1-based)*/
template<typename T>
void isce::io::Raster::setValue(T &buffer, size_t xidx, size_t yidx, size_t band) {
  getSetValue(buffer, xidx, yidx, band, GF_Write);
}


/**
 * @param[in] buffer Buffer to copy data from
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)*/
template<typename T>
void isce::io::Raster::setValue(T &buffer, size_t xidx, size_t yidx) {
  setValue(buffer, xidx, yidx, 1, GF_Write);
}


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 *                                          LINE OPERATIONS
 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 */
/**
 * @param[inout] buffer Raw pointer to buffer
 * @param[in] xidx Line location within band (0-based)
 * @param[in] iowidth Width of I/O buffer
 * @param[in] band Band index (1-based)
 * @param[in] iodir GDALRWFlag to indicate read / write
 *
 * Datatype translation is automatically determined using type of pointer passed*/
template<typename T>
void isce::io::Raster::getSetLine(T *buffer,          // i/o buffer of type T
				    size_t yidx,        // line location within band (0-indexed)
				    size_t iowidth,     // width of i/o buffer 
				    size_t band,        // band number (1-indexed)
				    GDALRWFlag iodir) { // i/o direction (GF_Read or GF_Write)

  if (GDT.count(typeid(T))) { // buffer type is supported by GDAL
    size_t rdwidth = std::min(iowidth, width()); // read the requested iowidth up to width()
    auto iostat = _dataset->GetRasterBand(band)->RasterIO(iodir, 0, yidx, rdwidth, 1, buffer,
							  rdwidth, 1, GDT.at(typeid(T)), 0, 0);
    
    if (iostat != CPLE_None) // RasterIO returned errors
      std::cout << "In isce::io::Raster::get/setLine() - error in RasterIO." << std::endl;
  }
  else 
    std::cout << "In isce::io::Raster::get/setLine() - Buffer datatype " << typeid(T).name() <<
      " is not mappable to a GDALDataType." << std::endl;

}



/** 
 * @param[in] buffer Raw pointer to buffer
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of samples to read 
 * @param[in] band Band index (1-based)*/
template<typename T>
void isce::io::Raster::getLine(T *buffer, size_t yidx, size_t iowidth, size_t band) {
  getSetLine(buffer, yidx, iowidth, band, GF_Read);
}


/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Width of buffer **/
template<typename T>
void isce::io::Raster::getLine(T *buffer, size_t yidx, size_t iowidth) {
  getLine(buffer, yidx, iowidth, 1);
}


// Get a line of data for given line position and band to std::vector. 
template<typename T>
void isce::io::Raster::getLine(std::vector<T> &buffer, size_t yidx, size_t band) {
  getLine(buffer.data(), yidx, buffer.size(), band);
}



// Get a line of data for given line position in band 1 to std::vector. 
template<typename T>
void isce::io::Raster::getLine(std::vector<T> &buffer, size_t yidx) {
  getLine(buffer.data(), yidx, buffer.size(), 1);
}



// Set a line of data for given line position and band from a std::valarray. 
template<typename T>
void isce::io::Raster::getLine(std::valarray<T> &buffer, size_t yidx, size_t band) {
  getLine(&buffer[0], yidx, buffer.size(), band);
}



// Set a line of data for given line position in band 1 from a std::valarray. 
template<typename T>
void isce::io::Raster::getLine(std::valarray<T> &buffer, size_t yidx) {
  getLine(&buffer[0], yidx, buffer.size(), 1);
}



/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of samples to write
 * @param[in] band Band index (1-based)*/
template<typename T>
void isce::io::Raster::setLine(T* buffer, size_t yidx, size_t iowidth, size_t band) {
  getSetLine(buffer, yidx, iowidth, band, GF_Write);
}


/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of samples to write*/
template<typename T>
void isce::io::Raster::setLine(T* buffer, size_t yidx, size_t iowidth) {
  setLine(buffer, yidx, iowidth, 1);
}



// Set a line of data for given line position and band from a std::vector. 
template<typename T>
void isce::io::Raster::setLine(std::vector<T> &buffer, size_t yidx, size_t band) {
  setLine(buffer.data(), yidx, buffer.size(), band);
}



// Set a line of data for given line position in band 1 from a std::vector. 
template<typename T>
void isce::io::Raster::setLine(std::vector<T> &buffer, size_t yidx) {
  setLine(buffer.data(), yidx, buffer.size(), 1);
}



// Set a line of data for given line position and band from a std::valarray. 
template<typename T>
void isce::io::Raster::setLine(std::valarray<T> &buffer, size_t yidx, size_t band) {
  setLine(&buffer[0], yidx, buffer.size(), band);
}



// Set a line of data for given line position in band 1 from a std::valarray. 
template<typename T>
void isce::io::Raster::setLine(std::valarray<T> &buffer, size_t yidx) {
  setLine(&buffer[0], yidx, buffer.size(), 1);
}



/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 *                                      BLOCK OPERATIONS
 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 */
// Get or set a 2D data block of width iowidth and length iolength given xidx/yidx positions in band
// and to/from 1D contigous buffer of width iowidth*iolength.
/**
 * @param[in] buffer Raw pointer for I/O
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of pixels to read/write
 * @param[in] iolength Number of lines to read/write
 *
 * Datatype translation is automatically determined from the type of buffer*/
template<typename T>
void isce::io::Raster::getSetBlock(T *buffer,            // i/o buffer of size iowidth*iolength
				     size_t xidx,          // column location within band (0-indexed)
				     size_t yidx,          // row location within band (0-indexed)
				     size_t iowidth,       // requested width of block of data
				     size_t iolength,      // requested length of block of data
				     size_t band,          // band number (1-indexed)
				     GDALRWFlag iodir) {   // i/o direction (GF_Read or GF_Write)
  
  if (GDT.count(typeid(T))) { // buffer type is supported by GDAL
    auto iostat = _dataset->GetRasterBand(band)->RasterIO(iodir, xidx, yidx, iowidth,
							  iolength, buffer, iowidth,
							  iolength, GDT.at(typeid(T)),
							  0, 0);
    
    if (iostat != CPLE_None) // RasterIO returned errors
      std::cout << "In isce::io::Raster::get/setValue() - error in RasterIO." << std::endl;
  }
  else
    std::cout << "In isce::io::Raster::get/setBlock() - Buffer datatype " << typeid(T).name() <<
      " is not mappable to a GDALDataType." << std::endl;
}


/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of pixels to read
 * @param[in] iolength Number of lines to read
 * @param[in] band Band index (1-based)*/
template<typename T>
void isce::io::Raster::getBlock(T *buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength, size_t band) {
  getSetBlock(buffer, xidx, yidx, iowidth, iolength, band, GF_Read);
}


/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of pixels to read
 * @param[in] iolength Number of lines to read*/
template<typename T>
void isce::io::Raster::getBlock(T *buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength) {
  getSetBlock(buffer, xidx, yidx, iowidth, iolength, 1, GF_Read);
}



// Get a block of data starting from given x/y position and size in band to std::vector. 
template<typename T>
void isce::io::Raster::getBlock(std::vector<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength, size_t band) {
  
  if ((iolength * iowidth) <= buffer.size()) { // buffer is larger or equal than requested block
    getBlock(buffer.data(), xidx, yidx, iowidth, iolength, band);
    
    if ((iolength * iowidth) < buffer.size())  // buffer is larger than requested block
      std::cout << "WARNING: In isce::io::Raster::getBlock() - Requested fewer elements than buffer size. " << std::endl;
    
  } else  // buffer is smaller than requested block
    throw std::length_error("In isce::io::Raster::getBlock() - Requested more elements than buffer size.");
}



// Get a block of data starting from given x/y position and size in band 1 to std::vector. 
template<typename T>
void isce::io::Raster::getBlock(std::vector<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength) {
  getBlock(buffer, xidx, yidx, iowidth, iolength, 1);
}



// Get a block of data starting from given x/y position and size in band to std::valarray. 
template<typename T>
void isce::io::Raster::getBlock(std::valarray<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength, size_t band) {
  
  if ((iolength * iowidth) <= buffer.size()) { // buffer is larger or equal than requested block
    getBlock(&buffer[0], xidx, yidx, iowidth, iolength, band);
    
    if ((iolength * iowidth) < buffer.size())  // buffer is larger than requested block
      std::cout << "WARNING: In isce::io::Raster::getBlock() - Requested fewer elements than buffer size. " << std::endl;
    
  } else  // buffer is smaller than requested block
    throw std::length_error("In isce::io::Raster::getBlock() - Requested more elements than buffer size.");
}



// Get a block of data starting from given x/y position and size in band 1 to std::valarray. 
template<typename T>
void isce::io::Raster::getBlock(std::valarray<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength) {
  getBlock(buffer, xidx, yidx, iowidth, iolength, 1);
}



/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of pixels to read
 * @param[in] iolength Number of lines to read
 * @param[in] band Band index (1-based)*/
template<typename T>
void isce::io::Raster::setBlock(T *buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength, size_t band) {
  getSetBlock(buffer, xidx, yidx, iowidth, iolength, band, GF_Write);
}


/**
 * @param[in] buffer Raw pointer to buffer
 * @param[in] xidx Pixel index (0-based)
 * @param[in] yidx Line index (0-based)
 * @param[in] iowidth Number of pixels to read
 * @param[in] iolength Number of lines to read*/
template<typename T>
void isce::io::Raster::setBlock(T *buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength) {
  getSetBlock(buffer, xidx, yidx, iowidth, iolength, 1, GF_Write);
}



// Set a block of data for given x/y position and size in band from a std::vector. 
template<typename T>
void isce::io::Raster::setBlock(std::vector<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength, size_t band) {
  
  if ((iolength * iowidth) <= buffer.size()) { // buffer is larger or equal than requested block
    setBlock(buffer.data(), xidx, yidx, iowidth, iolength, band);
    
    if ((iolength * iowidth) < buffer.size())  // buffer is larger than requested block
      std::cout << "WARNING: In isce::io::Raster::getBlock() - Requested fewer elements than buffer size. " << std::endl;
    
  } else  // buffer is smaller than requested block
    throw std::length_error("In isce::io::Raster::getBlock() - Requested more elements than buffer size.");
}



// Set a block of data for given x/y position and size in band 1 from a std::vector. 
template<typename T>
void isce::io::Raster::setBlock(std::vector<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength) {
  setBlock(buffer, xidx, yidx, iowidth, iolength, 1);
}



// Set a block of data for given x/y position and size in band from a std::vector. 
template<typename T>
void isce::io::Raster::setBlock(std::valarray<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength, size_t band) {
  
  if ((iolength * iowidth) <= buffer.size()) { // buffer is larger or equal than requested block
    setBlock(&buffer[0], xidx, yidx, iowidth, iolength, band);
    
    if ((iolength * iowidth) < buffer.size())  // buffer is larger than requested block
      std::cout << "WARNING: In isce::io::Raster::getBlock() - Requested fewer elements than buffer size. " << std::endl;
    
  } else  // buffer is smaller than requested block
    throw std::length_error("In isce::io::Raster::getBlock() - Requested more elements than buffer size.");
}



// Set a block of data for given x/y position and size in band 1 from a std::vector. 
template<typename T>
void isce::io::Raster::setBlock(std::valarray<T> &buffer, size_t xidx, size_t yidx,
				  size_t iowidth, size_t iolength) {
  setBlock(buffer, xidx, yidx, iowidth, iolength, 1);
}

/**
 * @param[in] arr Array of 6 double precision numbers
 *
 * No memory check performed for length of array*/
inline void isce::io::Raster::setGeoTransform(double* arr)
{
    int status = _dataset->SetGeoTransform(arr);
    if (status != 0)
    {
        throw "Could not set GDAL GeoTransform";
    }
}

/**
 * @param[in] arr std::vector of 6 double precision numbers*/
inline void isce::io::Raster::setGeoTransform(std::vector<double>& arr)
{
    if (arr.size() != 6)
    {
        throw std::length_error("In isce::io::setGeoTransform() - vector is not of size 6");
    }

    setGeoTransform(arr.data());
}

/**
 * @param[in] arr std::valarray of 6 double precision numbers*/
inline void isce::io::Raster::setGeoTransform(std::valarray<double>& arr)
{
    if (arr.size() != 6)
    {
        throw std::length_error("In isce::io::setGeoTransform() - valarray is not of size 6");
    }

    setGeoTransform(&arr[0]);
}

/**
 * @param[in] arr pointer to buffer of 6 double precision numbers
 *
 * No memory check is performed*/
inline void isce::io::Raster::getGeoTransform(double *arr) const
{
    int status = _dataset->GetGeoTransform(arr);
    if (status != 0 )
    {
        throw "Could not fetch GDAL GeoTransform";
    }
}

/**
 * @param[in] arr std::vector to copy GeoTransform into*/
inline void isce::io::Raster::getGeoTransform(std::vector<double>& arr) const
{
    if (arr.size() != 6)
    {
        throw std::length_error("In isce::io::Raster::getGeoTransform() - vector is not of size 6");
    }

    getGeoTransform(arr.data());
}

/**
 * @param[in] arr std::valarray to copy GeoTransform into*/
inline void isce::io::Raster::getGeoTransform(std::valarray<double>& arr) const
{
    if (arr.size() != 6)
    {
        throw std::length_error("In isce::io::Raster::getGeoTransform() - valarray is not of size 6");
    }

    getGeoTransform(&arr[0]);
}

//Return western edge
inline double isce::io::Raster::x0() const
{
    double trans[6];
    getGeoTransform(trans);
    return trans[0];
}

//Return northern edge
inline double isce::io::Raster::y0() const
{
    double trans[6];
    getGeoTransform(trans);
    return trans[3];
}

//Return EW pixel spacing
inline double isce::io::Raster::dx() const
{
    double trans[6];
    getGeoTransform(trans);
    return trans[1];
}

//Return NS pixel spacing
inline double isce::io::Raster::dy() const
{
    double trans[6];
    getGeoTransform(trans);
    return trans[5];
}

