runconfig:
    name: str()

    groups:
        pge_name_group:
            pge_name: enum('INSAR_L_PGE')

        input_file_group:
            reference_rslc_file: str()
            secondary_rslc_file: str()

            # REQUIRED for QA. NOT REQUIRED if only running Product SAS.
            # These field(s) should contain the filename of the
            # NISAR product(s) for QA to process.
            # If Product SAS and QA SAS are run back-to-back,
            # the(se) field(s) should be identical to filename convention
            # defined in `sas_output_file`.
            qa_rifg_input_file: str(required=False)
            qa_runw_input_file: str(required=False)
            qa_gunw_input_file: str(required=False)
            qa_roff_input_file: str(required=False)
            qa_goff_input_file: str(required=False)

        dynamic_ancillary_file_group:
            # REQUIRED - Digital elevation model
            dem_file: str()

            # PLACEHOLDER - Digital elevation model file description, optional
            dem_file_description: str(required=False)

            # Water distance map used for water mask in unwrapping and
            # 'water mask' field in GUNW product. The water water mask is
            # to have value from 0-100 (distance from coastline) and from
            # 101-200 (distance from inlandwater boundary)

            water_mask_file: str(required=False)
            orbit_files: include('external_orbit_options', required=False)

            # Troposphere weather model
            troposphere_weather_model_files: include('troposphere_weather_model_options', required=False)

            # TEC file used for geolocation correction. If no file present, no
            # TEC correction is applied
            tec_file: str(required=False)

        product_path_group:
            # Directory where PGE will place results
            product_path: str()
            product_counter: int(min=1, max=999, required=False)

            # Directory where SAS can write temporary data
            scratch_path: str()

            # Intermediate file name.  SAS writes output product to the following file.
            # After the SAS completes, the PGE wrapper renames the product file
            # according to proper file naming conventions.
            # In INSAR mode, GUNW, GOFF, RIFG, ROFF, and RUNW will be prepended to sas_output_file
            sas_output_file: str()

            # REQUIRED for QA. NOT REQUIRED if only running Product SAS.
            # Output directory to store all QA output files.
            # Because multiple InSAR products can be generated by this
            # runconfig, QA will make new product-specific directories
            # here to store the corresponding output files in.
            # Ex: if the output dir is set to './qa' and QA is requested for
            # RIFG and RUNW products, then QA will create './qa/rifg' and
            # './qa/runw' and save the respective QA outputs in these.
            qa_output_dir: str(required=False)

        primary_executable:
            # RIFG_RUNW_GUNW will produce all three InSAR products
            product_type: enum('GUNW', 'RIFG', 'RUNW', 'RIFG_RUNW_GUNW', 'ROFF_RIFG_RUNW_GOFF_GUNW', 'ROFF', 'GOFF', 'ROFF_GOFF')
            product_version: str('^\d+\.\d+\.\d+$', required=False)
            composite_release_id: regex(r'\w\d\d\d\d\d', name='CRID', required=False)
            processing_type: enum('PR', 'UR', required=False)
            product_accuracy: enum('P','M','N','F', required=False)
            urgent_request_id: list(str(), required=False)
            processing_center: str(required=False)
            partial_granule_id: str(required=False)

        debug_level_group:
            debug_switch: bool()

        #adt section - isce3 + pyre workflow
        processing:
            # Process single co-pol in offset and rubbersheeting
            # Setting to True to accommodate production environment
            process_single_co_pol_offset: bool(required=False)

            # Mechanism to select frequencies and polarizations
            input_subset:
                # List of frequencies to process. Default empty representing all
                list_of_frequencies:
                    # valid values for polarizations
                    # empty for all polarizations found in RSLC
                    # [polarizations] for list of specific frequency(s) e.g. [HH, HV] or [HH]
                    A: any(list(str(min=2, max=2), min=1, max=4), str(min=2, max=2), null(), required=False)
                    B: any(list(str(min=2, max=2), min=1, max=4), str(min=2, max=2), null(), required=False)

            # DEM download options: checked only if internet access is available
            dem_download: include('dem_download_options', required=False)

            # Geocode options (e.g. output posting)
            geocode: include('geocode_options', required=False)

            radar_grid_cubes:  include('radar_grid_cubes_options', required=False)

            bandpass: include('bandpass_options', required=False)

            ionosphere_phase_correction: include('ionosphere_phase_correction_options', required=False)

            troposphere_delay: include('troposphere_delay_options', required=False)

            rdr2geo: include('rdr2geo_options', required=False)

            geo2rdr: include('geo2rdr_options', required=False)

            # Coarse resample (geometry offsets only) options
            coarse_resample: include('coarse_resample_options', required=False)

            # Cross-correlation (Ampcor) options
            dense_offsets: include('dense_offsets_options', required=False)

            # Offset product options
            offsets_product: include('offsets_product_options', required=False)

            # Offset culling options
            rubbersheet: include('rubbersheet_options', required=False)

            # Fine resample (geometry + rubbersheeted dense offsets) options
            fine_resample: include('fine_resample_options', required=False)

            # Interferogram/coherence options (e.g. range looks)
            crossmul: include('crossmul_options', required=False)

            filter_interferogram: include('filter_interferogram_options', required=False)

            # Phase unwrapping options (e.g. unwrapping algorithm)
            phase_unwrap: include('phase_unwrap_options', required=False)

            # Baseline estimation options
            baseline: include('baseline_options', required=False)

        # To setup type of worker
        worker: include('worker_options', required=False)

        output: include('output_options', required=False)

        qa: include('qa_options', required=False)

        # Place holder for user set path to log file.
        # If not set, log sent to screen or input yaml path derived file
        logging: include('log_nfo', required=False)

---
external_orbit_options:
    reference_orbit_file: str(required=False)
    secondary_orbit_file: str(required=False)

troposphere_weather_model_options:
     reference_troposphere_file: str(required=False)
     secondary_troposphere_file: str(required=False)

phase_unwrap_options:
    crossmul_path: str(required=False)

    algorithm: enum('icu', 'phass', 'snaphu', required=False)

    range_looks: int(min=1, required=False)

    azimuth_looks: int(min=1, required=False)

    icu: include('icu_options', required=False)

    phass: include('phass_options', required=False)

    snaphu: include('snaphu_options', required=False)

    preprocess_wrapped_phase: include('preprocess_wrapped_phase_options', required=False)

icu_options:
    correlation_threshold_increments: num(min=0, max=1, required=False)
    seed: int(min=0, required=False)
    buffer_lines: int(min=1, required=False)
    overlap_lines: int(min=1, required=False)
    use_phase_gradient_neutron: bool(required=False)
    use_intensity_neutron: bool(required=False)
    phase_gradient_window_size: int(min=1, required=False)
    neutron_phase_gradient_threshold: num(min=0, required=False)
    neutron_intensity_threshold: num(min=0, required=False)
    max_intensity_correlation_threshold: num(required=False)
    trees_number: int(min=1, required=False)
    max_branch_length: int(min=1, required=False)
    pixel_spacing_ratio: num(required=False)
    initial_correlation_threshold: num(min=0, max=1, required=False)
    max_correlation_threshold: num(max=1, required=False)
    min_tile_area: num(required=False)
    bootstrap_lines: int(min=1, required=False)
    min_overlap_area: int(min=0, required=False)
    phase_variance_threshold: num(min=0, required=False)

phass_options:
    correlation_threshold_increments: num(min=0, max=1, required=False)
    good_correlation: num(min=0, max=1, required=False)
    min_unwrap_area: int(min=1, required=False)
    power: str(required=False)

snaphu_options:
    nlooks: num(min=1, required=False)
    cost_mode: enum('defo', 'smooth', 'p-norm', required=False)
    cost_mode_parameters: include('cost_mode_options', required=False)
    mask: str(required=False)
    unwrapped_phase_estimate: str(required=False)
    initialization_method: enum('mst', 'mcf', required=False)
    solver_parameters: include('solver_options', required=False)
    connected_components_parameters: include('connected_components_options', required=False)
    verbose: bool(required=False)
    debug: bool(required=False)

cost_mode_options:
    deformation_parameters: include('deformation_cost_options', required=False)
    smooth_parameters: include('smooth_cost_options', required=False)
    pnorm_parameters: include('pnorm_cost_options', required=False)

deformation_cost_options:
    azdz_factor: num(required=False)
    defo_max: num(min=0, required=False)
    sigsq_corr: num(min=0, required=False)
    defo_const: num(min=0, max=1, required=False)
    lay_falloff_const: num(required=False)
    kpar_dpsi: int(min=1, required=False)
    kperp_dpsi: int(min=1, required=False)

smooth_cost_options:
    kpar_dpsi: int(min=1, required=False)
    kperp_dpsi: int(min=1, required=False)

pnorm_cost_options:
    p: num(min=0, required=False)
    bidir: bool(required=False)

solver_options:
    max_flow_inc: int(min=0, required=False)
    init_max_flow: int(min=0, max=9999, required=False)
    arc_max_flow_const: int(required=False)
    threshold: num(required=False)
    max_cost: num(required=False)
    cost_scale: num(required=False)
    n_cycle: int(required=False)
    max_new_node_const: num(required=False)
    max_n_flow_cycles: num(required=False)
    max_cycle_frac: num(required=False)
    n_conn_node_min: int(min=0, required=False)
    n_major_prune: int(required=False)
    prune_cost_thresh: int(required=False)

connected_components_options:
    min_frac_area: num(required=False)
    cost_thresh: int(required=False)
    max_ncomps: int(required=False)

preprocess_wrapped_phase_options:
    enabled: bool(required=False)
    mask: include('unwrap_mask_options', required=False)
    filling_enabled: bool(required=False)
    filling_method: enum('distance_interpolator', required=False)
    distance_interpolator: include('distance_interp_options', required=False)

unwrap_mask_options:
    mask_type: enum('median_filter', 'coherence', 'water', required=False)
    mask_path: str(required=False)
    ocean_water_buffer: int(min=0, max=100, required=False)
    inland_water_buffer: int(min=0, max=100, required=False)
    outlier_threshold: num(min=0, required=False)
    median_filter_size: int(min=1, required=False)

distance_interp_options:
    distance: int(required=False)

coarse_resample_options:
    # Path to coarse/fine offset directory
    offsets_dir: str(required=False)

    # Number of lines per tile to resample in batch
    lines_per_tile: int(min=1, required=False)

fine_resample_options:
    # Flag to switch on/off fine resampling
    enabled: bool(required=False)

    # Path to coarse/fine offset directory
    offsets_dir: str(required=False)

    # Number of lines per tile to resample in batch
    lines_per_tile: int(min=1, required=False)

dense_offsets_options:
    # Flag to enable/disable dense offsets estimation. Default: True
    enabled: bool(required=False)

    # Lines per block to process in batch
    lines_per_block: int(min=1, required=False)

    # Path to HDF5 file or directory with geometry-coregistered SLCs.
    # Not required as we allow the use of intermediate outputs from
    # the previous InSAR module, which is not user-specified
    coregistered_slc_path: str(required=False)

    # Number of columns for chip/template window in reference image
    window_range: int(min=16, max=512, required=False)

    # Number of lines for chip/template window in reference image
    window_azimuth: int(min=16, max=512, required=False)

    # Number of columns for search chip/template in secondary image
    half_search_range: int(min=4, max=128, required=False)

    # Number of lines for search chip/template in secondary image
    half_search_azimuth: int(min=4, max=128, required=False)

    # Number of columns to skip in reference image for next offset estimate
    skip_range: int(min=1, required=False)

    # Number of lines to skip in reference image for next offset estimate
    skip_azimuth: int(min=1, required=False)

    # Margin around image edges to avoid for offset computation
    margin: int(min=0, required=False)

    # Number of columns of output offset (covariance, snr) file
    offset_width: int(required=False)

    # Number of lines of output offset (covariance, snr) file
    offset_length: int(required=False)

    # Start pixel of the reference image along slant range
    start_pixel_range: int(min=0, required=False)

    # Start pixel of the reference image along azimuth
    start_pixel_azimuth: int(min=0, required=False)

    # Domain (frequency or spatial) where to compute cross-correlation
    cross_correlation_domain: enum('frequency', 'spatial', required=False)

    # Anti-aliasing oversampling factor to apply to reference/secondary SLC
    # prior to cross-correlation computation
    slc_oversampling_factor: int(min=2, max=5, required=False)

    # Deramp data prior to FFT: magnitude or complex (linear phase ramp)
    deramping_method: enum('magnitude', 'complex', required=False)

    # Flag to use constant range/azimuth offsets in dense offsets estimation
    use_gross_offsets: bool(required=False)

    # Constant offset along slant range to guide dense offset estimation
    gross_offset_range: int(required=False)

    # Constant gross offset along az to guide dense offset estimation
    gross_offset_azimuth: int(required=False)

    # File path to pixel by pixel gross offset (e.g. from reference velocity map)
    gross_offset_filepath: str(required=False)

    # Flag to add gross offset to the output of dense offset file
    merge_gross_offset: bool(required=False)

    # Square zoom window size for cross-correlation statistics (SNR, covariance)
    correlation_statistics_zoom: int(required=False)

    # Square zoom window size for sub-pixel offset refinement
    correlation_surface_zoom: int(min=4, required=False)

    # Oversampling factor of the correlation surface for sub-pixel offset refinement
    correlation_surface_oversampling_factor: int(min=2, max=128, required=False)

    # Correlation surface oversampling algorithm
    correlation_surface_oversampling_method: enum('sinc', 'fft', required=False)

    # Number of cuda streams
    cuda_streams: int(required=False)

    # Number of offset estimates to process in batch along slant range
    windows_batch_range: int(min=1, required=False)

    # Number of offset estimates to process in batch along azimuth
    windows_batch_azimuth: int(min=1, required=False)


offsets_product_options:
    # Flag to enable/disable offsets product computation (default: False)
    enabled: bool(required=False)

    # Lines per block to process in batch
    lines_per_block: int(min=1, required=False)

    # Path to HDF5 file or directory with geometry-coregistered SLCs.
    # Not required as we allow the use of intermediate outputs from
    # the previous InSAR module, which is not user-specified
    coregistered_slc_path: str(required=False)

    # Number of columns to skip in reference image for next offset estimate
    skip_range: int(min=1, required=False)

    # Number of lines to skip in reference image for next offset estimate
    skip_azimuth: int(min=1, required=False)

    # Margin around image edges to avoid for offset computation
    margin: int(min=0, required=False)

    # Number of columns of output offset (covariance, snr) file
    offset_width: int(required=False)

    # Number of lines of output offset (covariance, snr) file
    offset_length: int(required=False)

    # Start pixel of the reference image along slant range
    start_pixel_range: int(min=0, required=False)

    # Start pixel of the reference image along azimuth
    start_pixel_azimuth: int(min=0, required=False)

    # Domain (frequency or spatial) where to compute cross-correlation
    cross_correlation_domain: enum('frequency', 'spatial', required=False)

    # Anti-aliasing oversampling factor to apply to reference/secondary SLC
    # prior to cross-correlation computation
    slc_oversampling_factor: int(min=2, max=5, required=False)

    # Deramp data prior to FFT: magnitude or complex (linear phase ramp)
    deramping_method: enum('magnitude', 'complex', required=False)

    # Flag to use constant range/azimuth offsets in dense offsets estimation
    use_gross_offsets: bool(required=False)

    # Constant offset along slant range to guide dense offset estimation
    gross_offset_range: int(required=False)

    # Constant gross offset along az to guide dense offset estimation
    gross_offset_azimuth: int(required=False)

    # File path to pixel by pixel gross offset (e.g. from reference velocity map)
    gross_offset_filepath: str(required=False)

    # Flag to add gross offset to the output of dense offset file
    merge_gross_offset: bool(required=False)

    # Square zoom window size for cross-correlation statistics (SNR, covariance)
    correlation_statistics_zoom: int(required=False)

    # Square zoom window size for sub-pixel offset refinement
    correlation_surface_zoom: int(min=4, required=False)

    # Oversampling factor of the correlation surface for sub-pixel offset refinement
    correlation_surface_oversampling_factor: int(min=2, max=128, required=False)

    # Correlation surface oversampling algorithm
    correlation_surface_oversampling_method: enum('sinc', 'fft', required=False)

    # Number of cuda streams
    cuda_streams: int(required=False)

    # Number of offset estimates to process in batch along slant range
    windows_batch_range: int(min=1, required=False)

    # Number of offset estimates to process in batch along azimuth
    windows_batch_azimuth: int(min=1, required=False)

    # Pixel offsets layers
    layer1: include('offset_layer_options', required=False)
    layer2: include('offset_layer_options', required=False)
    layer3: include('offset_layer_options', required=False)
    layer4: include('offset_layer_options', required=False)

offset_layer_options:
    # Cross-correlation method (incoherent; coherent not implemented)
    cross_correlation_method: enum('coherent', 'incoherent', required=False)

    # Number of columns for chip/template window in reference image
    window_range: int(min=16, max=512, required=False)

    # Number of lines for chip/template window in reference image
    window_azimuth: int(min=16, max=512, required=False)

    # Number of columns for search chip/template in secondary image
    half_search_range: int(min=4, max=32, required=False)

    # Number of lines for search chip/template in secondary image
    half_search_azimuth: int(min=4, max=32, required=False)

rubbersheet_options:
    # Path to dense offsets outputs (offsets, snr, covariance).
    # Not required as InSAR workflow allows using intermediate outputs
    # from previous steps (not user-specified)
    dense_offsets_path: str(required=False)

    # Path to offsets product directory (offsets, snr, covariance).
    # Not required as InSAR workflow allows using intermediate outputs
    # from previous steps (not user-specified)
    offsets_product_path: str(required=False)

    # Path to geo2rdr offset path
    geo2rdr_offsets_path: str(required=False)

    # Flag to enable/disable rubbersheet step
    enabled: bool(required=False)

    # Metric used to identify offsets outliers
    culling_metric: enum('snr', 'median_filter', 'covariance', required=False)

    # Size of median filter in range. Median filter is used
    # for offset outlier identification.
    median_filter_size_range: int(min=3, required=False)

    # Size of median filter in azimuth (see above)
    median_filter_size_azimuth: int(min=3, required=False)

    # Threshold for outlier identification. Depends on "culling_metric".
    # SNR: offsets with SNR below threshold are identified as outliers
    # Covariance: offsets with range/azimuth covariance above threshold are outliers
    # Median filter: offsets with median absolute deviation above thresholds are outliers
    threshold: num(min=0, required=False)

    # Flag to enable mask refinement The intent of this refinement is to remove
    # noisy spots on 1-2 pixels after the first outlier identification.
    # The refinement is performed by thresholding the median absolute deviation of
    # the offsets where outlier locations have been filled with zeros
    mask_refine_enabled: bool(required=False)

    # Threshold for outlier refinement mask computation
    mask_refine_threshold: num(min=0, required=False)

    # Size of median filter in range and azimuth for outlier mask refinement
    mask_refine_filter_size: int(min=3, max=7, required=False)

    # Method to fill data holes left by outliers culling:
    # fill_smoothed: iteratively fill holes with mean value in a neighborhood.
    # nearest_neighbor: Fill holes with nearest neighbor interpolation
    outlier_filling_method: enum('fill_smoothed', 'nearest_neighbor', required=False)

    # Fill smoothed option
    fill_smoothed: include('fill_smoothed_options', required=False)

    # Interpolation method. Interpolation is used to fill residual
    # outlier holes (if present)
    interpolation_method: enum('nearest', 'linear', 'cubic', required=False)

    # It is good practice to filter the offsets prior to interferogram
    # formation to reduce noise. We expose: no_filter: do not filter the offsets/
    # degrade offsets resolution. median_filter, boxcar_filter (moving average),
    # gaussian_filter
    offsets_filter: enum('none', 'median', 'boxcar', 'gaussian', required=False)
    median: include('offset_filter_options', required=False)
    boxcar: include('offset_filter_options', required=False)
    gaussian: include('gaussian_filter_options', required=False)

fill_smoothed_options:
    # Number of fill smoothed iterations
    iterations: int(min=1, required=False)

    # Size of neighborhood where to look for smoothed values
    kernel_size: int(min=3, required=False)

offset_filter_options:
    # Filter size (median/boxcar) in slant range
    filter_size_range: int(min=3, required=False)

    # Filter size (median/boxcar) in azimuth
    filter_size_azimuth: int(min=3, required=False)

gaussian_filter_options:
    # Gaussian filter standard deviation along slant range
    sigma_range: num(min=0, required=False)
    # Gaussian filter standard deviation along azimuth
    sigma_azimuth: num(min=0, required=False)
    # Number of rows for 1D gaussian kernel
    filter_size_azimuth: int(min=1, required=False)
    # Number of columns for 1D gaussian kernel
    filter_size_range: int(min=1, required=False)

crossmul_options:
    # Path to HDF5 file or directory with coregistered SLCs
    # If directory then the following directory tree is required:
    # coregistered_slc_path
    # └── coregistered_secondary
    #      └── freq(A,B)
    #          └── (HH, HV, VH, VV)
    #              └── coregistered_secondary.slc
    coregistered_slc_path: str(required=False)

    # Number of looks in slant range direction
    range_looks: int(min=1,  required=False)

    # Number of looks in azimuth direction
    azimuth_looks: int(min=1,  required=False)

    # flatten is False disables flatten
    # flatten is True runs flatten in crossmul
    # flatten_path is the path to data directory
    # Data directory contains range offset rasters
    # The following directory tree is required in flatten_path:
    # flatten
    # └── geo2rdr
    #     └── freq(A,B)
    #         └── range.off
    # flatten defaults to True
    # flatten_path defaults to scratch_path
    flatten: bool(required=False)
    flatten_path: str(min=1, required=False)

    # Oversampling factor (avoids aliasing during interferogram formation)
    oversample: int(min=1, required=False)

    # Number of lines per block to process in batch
    lines_per_block: int(min=1, required=False)

    common_band_range_filter: bool(required=False)

    common_band_azimuth_filter: bool(required=False)

filter_interferogram_options:
    # Path to HDF5 or directory containing complex interferogram
    # Not required as InSAR workflow allows using intermediate outputs
    # from previous steps (not user-specified)
    interferogram_path: str(required=False)

    # Options to set frequency/polarization dependent masks during filtering
    mask: include('filter_mask_options', required=False)

    # Blocksize, for block-processing usage on insar_filtering.py
    lines_per_block: int(min=1, required=False)

    # Filter type to be used in interferogram filtering. Available options:
    # no filter, boxcar, gaussian
    filter_type: enum('no_filter', 'boxcar', 'gaussian', required=False)

    # Boxcar filter options: kernel sizes in slant range and azimuth
    boxcar: include('offset_filter_options', required=False)

    # Gaussian filter options: standard deviation in slant range and azimuth
    gaussian: include('gaussian_filter_options', required=False)

filter_mask_options:
    # Filepath to one mask to be applied for each frequency and polarization
    general: str(required=False)

    # Filepath to the masks applied to filter frequency A rasters
    A: include('freq_pol_masks', required=False)

    # Filepath to the masks applied to filter frequency B rasters
    B: include('freq_pol_masks', required=False)

freq_pol_masks:
    # Filepath to masks for filtering HH, HV, VH, and VV raster layers
    HH: str(required=False)
    HV: str(required=False)
    VH: str(required=False)
    VV: str(required=False)

baseline_options:
    # 3D_full: compute baselines for all heights in metadata cube
    # top_bottom: compute baselines for top and bottom heights
    mode: enum('3D_full', 'top_bottom', required=False)

radar_grid_cubes_options:

    # List of heights in meters
    heights: list(num(), required=False)

    # Same as input DEM if not provided.
    output_epsg: int(min=1024, max=32767, required=False)

    # Output posting in same units as output EPSG.
    # If not provided, spacing values will be taken from provided DEM.
    output_posting:
        x_posting: num(min=0, required=False)
        y_posting: num(min=0, required=False)

    # To control output grid in same units as output EPSG
    x_snap: num(min=0, required=False)

    # To control output grid in same units as output EPSG
    y_snap: num(min=0, required=False)

    top_left:
        # Set top-left y in same units as output EPSG
        y_abs: num(required=False)

        # Set top-left x in same units as output EPSG
        x_abs: num(required=False)

    bottom_right:
        # Set bottom-right y in same units as output EPSG
        y_abs: num(required=False)

        # Set bottom-right x in same units as output EPSG
        x_abs: num(required=False)

bandpass_options:
    # Number of lines per block
    lines_per_block: int(min=1, required=False)
    # Set window function for range spectrum bandpass filtering
    window_function: enum('tukey', 'cosine', 'kaiser', required=False)
    # Shape parameter. For Kaiser, 0 <= shape < Inf.
    # For Cosine and Tukey, 0 <= shape <= 1
    window_shape: num(min=0, required=False)
    range_fft_size: int(min=1, required=False)

ionosphere_phase_correction_options:
    # Boolean flag to enable/disable ionosphere phase correction
    enabled: bool(required=False)
    # 'split_main_band' splits the main range bandwidth into a low and high subband
    # being 1/3 (fixed for now) of the total main range spectrum.
    # 'main_side_band' uses the additional NISAR 5 MHz side-band to estimate the
    # ionosphere phase screen. Main and side-bands are intended to be at the same polarization
    spectral_diversity: enum('split_main_band', 'main_side_band', 'main_diff_ms_band', required=False)
    split_range_spectrum: include('split_range_spectrum_options', required=False)
    list_of_frequencies: include('ionosphere_freq_pol_options', required=False)
    dispersive_filter: include('dispersive_filter_options', required=False)
    # Number of lines per block for block processing)
    lines_per_block: int(min=1, required=False)

dispersive_filter_options:
    # Boolean flag to enable/disable ionosphere phase correction
    enabled: bool(required=False)
    # Source for mask generation
    # median filter : use theoretical standard deviation calculated from coherence and
    #                 detect area below 3 * std.
    # coherence : define invalid region using coherence below 'filter_coherence_threshold'
    # connected_components: define invalid region where connected_components equal to 0.
    filter_mask_type: enum('median_filter', 'coherence', 'connected_components', required=False)
    # Median filter size for mask generation
    median_filter_size: num(min=1, required=False)
    # coherence threshold for mask generation
    filter_coherence_threshold: num(min=0, max=1, required=False)
    # Filling method for invalid regions
    # nearest : apply nearest interpolation for whole invalid regions
    # smoothed : apply lienar interpolation and nearest extrapolations
    filling_method: enum('nearest', 'smoothed', 'None', required=False)
    # Flag for enabling/disabling of upwrapping error estimation/correction
    unwrap_correction: bool(required=False)
    # 1D gaussian kernel size [pixels] in range/ azimuth
    kernel_range: num(min=1, required=False)
    kernel_azimuth: num(min=1, required=False)
    # Gaussian filter standard deviation along range
    sigma_range: num(min=1, required=False)
    # Gaussian filter standard deviation along azimuth
    sigma_azimuth: num(min=1, required=False)
    filter_iterations: num(min=1, max=10, required=False)

split_range_spectrum_options:
    # Number of lines per block for block processing)
    lines_per_block: int(min=1, required=False)
    # Low bandwidth. If unspecified is automatically set by the workflow according to
    # the selected spectral diversity
    low_band_bandwidth: num(min=0, required=False)
    # High bandwidth. If unspecified, it is automatically set by the workflow
    high_band_bandwidth: num(min=0, required=False)
    # Type of window used to taper range spectrum
    window_function: enum('tukey', 'cosine', 'kaiser', required=False)
    # Shape parameter. For Kaiser, 0 <= shape < Inf.
    # For Cosine and Tukey, 0 <= shape <= 1
    window_shape: num(min=0, required=False)

ionosphere_freq_pol_options:
    # valid values for polarizations
    # empty for all polarizations found in RSLC
    # [polarizations] for list of specific frequency(s) e.g. [HH, HV] or [HH]
    A: any(list(str(min=2, max=2), min=1, max=4), str(min=2, max=2), null(), required=False)
    B: any(list(str(min=2, max=2), min=1, max=4), str(min=2, max=2), null(), required=False)

troposphere_delay_options:
    # Boolean flag to enable/disable troposphere delay computation
    enabled: bool(required=False)
    # Package used by troposphere delay computation
    package: enum('pyaps', 'raider', required=False)
    # Weather model type
    weather_model_type: enum('ERA5', 'ERAINT', 'HRES', 'NARR', 'MERRA', 'ECMWF', 'ERAI', 'GMAO', 'HRRR', 'NCMR',required=False)
    # Delay direction. 'zenith' is the zenith delay, line_of_sight_mapping is the delay projected
    # from zenith, and line_of_sight_raytracing is the delay by raytracing method by raider package
    delay_direction: enum('zenith', 'line_of_sight_mapping', 'line_of_sight_raytracing', required=False)
    # Boolean flag to enable/disable delay products, where comb product is the summation of wet and dry
    enable_wet_product: bool(required=False)
    enable_hydrostatic_product: bool(required=False)
    enable_comb_product: bool(required=False)

geo2rdr_options:
    # Convergence threshold for geo2rdr algorithm
    threshold: num(min=0, required=False)

    # Maximum number of iterations
    maxiter: int(min=1, required=False)

    # Path to a directory in which to store rdr2geo (topo) outputs. If the
    # directory does not exist, it will be created. Required only for
    # stand-alone usage of geo2rdr.py
    topo_path: str(required=False)

    # Line per block to
    lines_per_block: int(min=1, required=False)

rdr2geo_options:
    # Convergence threshold for rdr2geo algorithm
    threshold: num(min=0, required=False)

    # Maximum number of iterations
    numiter: int(min=1, required=False)

    # Extra/secondary number of iterations
    extraiter: int(min=1, required=False)

    # Line per block to
    lines_per_block: int(min=1, required=False)

    # Flags for enabling/disabling layers written in rdr2geo/topo
    # default to save only layers needed for geo2rdr + InSAR
    # x, y, and height required for geo2rdr and InSAR
    # layover_shadow required for InSAR
    write_x: bool(required=False)
    write_y: bool(required=False)
    write_z: bool(required=False)
    write_height: bool(required=False)
    write_incidence: bool(required=False)
    write_heading: bool(required=False)
    write_local_incidence: bool(required=False)
    write_local_psi: bool(required=False)
    write_simulated_amplitude: bool(required=False)
    write_layover_shadow: bool(required=False)

log_nfo:
    # Path to log file
    path: str()

    # Log file write mode. 'a' for append to existing. 'w' for new or overwrite existing.
    write_mode: enum('a', 'w', required=False)

qa_options:
    # For descriptions of all QA parameters, see template runconfig (in `defaults` directory)
    rifg: include('rifg_options', required=False)
    runw: include('runw_options', required=False)
    gunw: include('gunw_options', required=False)
    roff: include('roff_options', required=False)
    goff: include('goff_options', required=False)

rifg_options:
    workflows: include('workflows_options', required=False)
    qa_reports: include('rifg_qa_reports_options', required=False)

rifg_qa_reports_options:
    hsi_img: include('qa_hsi_img_wrapped_options', required=False)

runw_options:
    workflows: include('workflows_options', required=False)
    qa_reports: include('runw_qa_reports_options', required=False)

runw_qa_reports_options:
    phase_img: include('qa_phase_img_options', required=False)
    hsi_img: include('qa_hsi_img_unwrapped_options', required=False)

gunw_options:
    workflows: include('workflows_options', required=False)
    qa_reports: include('gunw_qa_reports_options', required=False)

gunw_qa_reports_options:
    phase_img: include('qa_phase_img_options', required=False)
    hsi_img: include('qa_hsi_img_unwrapped_options', required=False)

roff_options:
    workflows: include('workflows_options', required=False)
    qa_reports: include('offsets_qa_reports_options', required=False)

goff_options:
    workflows: include('workflows_options', required=False)
    qa_reports: include('offsets_qa_reports_options', required=False)

offsets_qa_reports_options:
    quiver_plots: include('qa_quiver_plots_options', required=False)

workflows_options:
    validate: bool(required=False)
    qa_reports: bool(required=False)

qa_phase_img_options:
    rewrap: num(min=0.0, required=False)

qa_hsi_img_wrapped_options:
    equalize_browse: bool(required=False)
    longest_side_max: int(min=1, required=False)

qa_hsi_img_unwrapped_options:
    equalize_browse: bool(required=False)
    longest_side_max: int(min=1, required=False)
    rewrap: num(min=0.0, required=False)

qa_quiver_plots_options:
    colorbar_min_max: list(num, min=2, max=2, required=False)
    browse_decimation_freqa: list(int(min=1), min=2, max=2, required=False)
    browse_decimation_freqb: list(int(min=1), min=2, max=2, required=False)
    arrow_density: num(min=1.0, required=False)
    arrow_scaling: num(min=0.0, required=False)
    longest_side_max: int(min=1, required=False)


dem_download_options:
    # s3 bucket / curl URL / local file
    source: str(required=False)

    top_left:
        # Top-left X coordinate
        x: num(required=False)
        # To-left Y coordinate
        y: num(required=False)

    bottom_right:
        # Bottom-right X coordinate
        x: num(required=False)
        # Bottom-right Y coordinate
        y: num(required=False)

geocode_options:
    # Required for geocode standalone of RUNW
    runw_path: str(required=False)

    # Required for geocode standalone of ROFF
    roff_path: str(required=False)

    # Required for geocode standalone of RIFG
    rifg_path: str(required=False)

    # DEM interpolation method. BILINEAR is default.
    interp_method: enum('BILINEAR', 'BICUBIC', 'NEAREST', 'BIQUINTIC', required=False)

    # Rasters in RUNW to geocode
    gunw_datasets: include('gunw_datasets', required=False)

    # Rasters in ROFF to geocode
    goff_datasets: include('goff_datasets', required=False)

    # Same as input DEM if not provided.
    output_epsg: int(min=1024, max=32767, required=False)

    # Output posting in same units as output EPSG.
    # If not provided, spacing values will be taken from provided DEM.
    output_posting: include('output_posting_options', required=False)

    # Wrapped Interferogram output posting in same units as output EPSG.
    # If not provided, spacing values will be taken from provided DEM.
    wrapped_interferogram: include('wrapped_interferogram_options',required=False)

    # To control output grid in same units as output EPSG
    x_snap: num(min=0, required=False)

    # To control output grid in same units as output EPSG
    y_snap: num(min=0, required=False)

    top_left:
        # Set top-left y in same units as output EPSG
        y_abs: num(required=False)

        # Set top-left x in same units as output EPSG
        x_abs: num(required=False)

    bottom_right:
        # Set bottom-right y in same units as output EPSG
        y_abs: num(required=False)

        # Set bottom-right x in same units as output EPSG
        x_abs: num(required=False)

    # Set lines to be processed per block
    lines_per_block: int(min=100, max=10000, required=False)

gunw_datasets:
    connected_components: bool(required=False)
    coherence_magnitude: bool(required=False)
    unwrapped_phase: bool(required=False)
    layover_shadow_mask: bool(required=False)
    along_track_offset: bool(required=False)
    slant_range_offset: bool(required=False)
    correlation_surface_peak: bool(required=False)

goff_datasets:
    along_track_offset: bool(required=False)
    along_track_offset_variance: bool(required=False)
    correlation_surface_peak: bool(required=False)
    cross_offset_variance: bool(required=False)
    slant_range_offset: bool(required=False)
    slant_range_offset_variance: bool(required=False)
    snr: bool(required=False)

wrapped_interferogram_options:
    interp_method: enum('SINC', 'BILINEAR', 'BICUBIC', 'NEAREST', 'BIQUINTIC', required=False)
    x_snap: num(min=0, required=False)
    y_snap: num(min=0, required=False)
    output_posting: include('output_posting_options', required=False)

output_posting_options:
    A: include('posting_options', required=False)
    B: include('posting_options', required=False)

posting_options:
    x_posting: num(min=0, required=False)
    y_posting: num(min=0, required=False)

worker_options:
    # Enable/disable internet connection (e.g. for download DEM)
    internet_access: bool(required=False)

    # To explicitly use GPU capability if available. Default False
    gpu_enabled: bool(required=False)

    # Index of the GPU to use for processing, optional. Defaults to the
    # first available CUDA device. Ignored if *gpu_enabled* is False.
    gpu_id: int(min=0, required=False)

output_options:
    compression_enabled: bool(required=False)
    compression_level: int(min=1, max=9, required=False)
    chunk_size: list(int(min=4), min=2, max=2, required=False)
    shuffle: bool(required=False)
