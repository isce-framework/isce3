//-*- C++ -*-
//-*- coding: utf-8 -*-

#include <iostream>
#include <cmath>
#include <valarray>
#include <vector>
#include "gtest/gtest.h"

// isce3::core
#include "isce3/core/LUT1d.h"
#include "isce3/core/LUT2d.h"
#include "isce3/core/Matrix.h"
#include "isce3/core/Utilities.h"

// Reference values generated by scipy.interpolate.interp1d example
std::valarray<double> ref_vals{
    1.5669373788524215, 1.485946324730647, 1.4049552706088724, 1.323964216487098,
    1.2429731623653235, 1.161982108243549, 1.0809910541217744, 1.0, 0.9190089458782256,
    0.8380178917564511, 0.7570268376346766, 0.6875149974964754, 0.6294823713418476,
    0.5714497451872198, 0.513417119032592, 0.47183492535797783, 0.43025273168336364,
    0.3886705380087495, 0.3529819693063402, 0.3231870255761357, 0.2933920818459313,
    0.26359713811572677, 0.2422481280362511, 0.2208991179567754, 0.1995501078772997,
    0.18122698575171198, 0.16592975158001225, 0.1506325174083125, 0.1353352832366127,
    0.12437433598741056, 0.11341338873820835, 0.1024524414890062, 0.09304503691560456,
    0.08519117501800354, 0.07733731312040257, 0.06948345122280154, 0.06385591326424796,
    0.05822837530569435, 0.05260083734714077, 0.04697329938858716, 0.04134576143003357,
    0.03571822347147996, 0.030090685512926346, 0.024463147554372768, 0.018835609595819154,
    0.013208071637265575, 0.007580533678711955, 0.0019529957201583764, -0.003674542238395237,
    -0.00930208019694885
};

TEST(LUT1dTest, Lookup) {

    // Construct coordinates and values for LUT
    const size_t n = 10;
    std::valarray<double> coords(n), values(n);
    for (size_t i = 0; i < n; ++i) {
        coords[i] = i;
        values[i] = std::exp(-1.0 * i / 3.0);
    }

    // Create LUT with extrapolation beyond the coordinate bounds
    isce3::core::LUT1d<double> lut(coords, values, true);

    // Construct coordinates for evaluating LUT
    const size_t n_eval = 50;
    std::vector<double> xvec = isce3::core::linspace(-2.0, 12.0, n_eval);
    std::valarray<double> x_eval(xvec.data(), xvec.size());

    // Evaluate LUT
    for (size_t i = 0; i < n_eval; ++i) {
        double value = lut.eval(x_eval[i]);
        EXPECT_NEAR(value, ref_vals[i], 1.0e-13);
    }
}

TEST(LUT1dTest, AvgLUT2dToLUT1d) {
    // Create indices
    std::vector<double> xvec = isce3::core::arange(0., 3., 1.);
    std::vector<double> yvec = isce3::core::arange(0., 5., 1.);
    size_t nx = xvec.size();
    size_t ny = yvec.size();

    // Copy them to valarrays
    std::valarray<double> xindex(xvec.data(), xvec.size());
    std::valarray<double> yindex(yvec.data(), yvec.size());

    // Allocate the matrix
    isce3::core::Matrix<double> M;
    M.resize(ny, nx);

    // Fill values
    auto n_elem = ny * nx;
    for (size_t i = 0; i < n_elem; ++i) {
        auto i_col = i % nx;
        auto i_row = i / nx;
        M(i_row, i_col) = static_cast<double>(i);
    }

    // Create LUT2d
    isce3::core::LUT2d<double> lut2d(xindex, yindex, M,
                                     isce3::core::BIQUINTIC_METHOD);

    // Expected average values for both axis
    std::valarray<double> avg_axis0{6., 7., 8.};
    std::valarray<double> avg_axis1{1., 4., 7., 10., 13.};

    // Average along both axis and check results
    for (int i_axis = 0; i_axis < 2; ++i_axis) {
        auto lut1d = isce3::core::avgLUT2dToLUT1d(lut2d, i_axis);
        auto vals = lut1d.values();

        for (size_t j = 0; j < lut1d.size(); ++j)
            ASSERT_EQ(vals[j], (i_axis == 0) ? avg_axis0[j] : avg_axis1[j]);
    }
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

// end of file
