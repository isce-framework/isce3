<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>isce3: isce3::io::IDataSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">isce3
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="sphinx/html/index.html"><span>Python&#160;classes</span></a></li>
      <li><a href="https://github-fn.jpl.nasa.gov/isce-3/isce/issues/"><span>Issue&#160;Tracker</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceisce3.html">isce3</a></li><li class="navelem"><a class="el" href="namespaceisce3_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classisce3_1_1io_1_1IDataSet.html">IDataSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classisce3_1_1io_1_1IDataSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">isce3::io::IDataSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Our derived dataset structure that includes utility functions.  
 <a href="classisce3_1_1io_1_1IDataSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IH5_8h_source.html">IH5.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for isce3::io::IDataSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classisce3_1_1io_1_1IDataSet.png" usemap="#isce3::io::IDataSet_map" alt=""/>
  <map id="isce3::io::IDataSet_map" name="isce3::io::IDataSet_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb53ce395a0b2bf7ab4e95ca772bca16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb53ce395a0b2bf7ab4e95ca772bca16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IDataSet</b> (const H5::DataSet &amp;dset)</td></tr>
<tr class="separator:aeb53ce395a0b2bf7ab4e95ca772bca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbfecda372c732043aab0216ca1a2e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecbfecda372c732043aab0216ca1a2e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IDataSet</b> (const hid_t id)</td></tr>
<tr class="separator:aecbfecda372c732043aab0216ca1a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d21df7bb99115334d350b8d6b1f815"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ab9d21df7bb99115334d350b8d6b1f815">getAttrs</a> ()</td></tr>
<tr class="memdesc:ab9d21df7bb99115334d350b8d6b1f815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of attributes attached to dataset.  <a href="#ab9d21df7bb99115334d350b8d6b1f815">More...</a><br/></td></tr>
<tr class="separator:ab9d21df7bb99115334d350b8d6b1f815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c854660fdb2748ccdff4d49c5e82c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82c854660fdb2748ccdff4d49c5e82c6"></a>
H5::DataSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a82c854660fdb2748ccdff4d49c5e82c6">getDataSpace</a> (const std::string &amp;v=&quot;&quot;)</td></tr>
<tr class="memdesc:a82c854660fdb2748ccdff4d49c5e82c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a HDF5 DataSpace object corresponding to dataset or given attribute. <br/></td></tr>
<tr class="separator:a82c854660fdb2748ccdff4d49c5e82c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae842fcf66ce0b8ab77b406fc861a363"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#aae842fcf66ce0b8ab77b406fc861a363">getRank</a> (const std::string &amp;v=&quot;&quot;)</td></tr>
<tr class="memdesc:aae842fcf66ce0b8ab77b406fc861a363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimension of dataset or given attribute.  <a href="#aae842fcf66ce0b8ab77b406fc861a363">More...</a><br/></td></tr>
<tr class="separator:aae842fcf66ce0b8ab77b406fc861a363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988b34554751329f497038d7465320fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a988b34554751329f497038d7465320fa">getNumElements</a> (const std::string &amp;v=&quot;&quot;)</td></tr>
<tr class="memdesc:a988b34554751329f497038d7465320fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of elements contained in dataset or given attribute.  <a href="#a988b34554751329f497038d7465320fa">More...</a><br/></td></tr>
<tr class="separator:a988b34554751329f497038d7465320fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0f7e995104fac4c26ada4210092493"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a8b0f7e995104fac4c26ada4210092493">getDimensions</a> (const std::string &amp;v=&quot;&quot;)</td></tr>
<tr class="memdesc:a8b0f7e995104fac4c26ada4210092493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of each dimension of the dataset or given attribute.  <a href="#a8b0f7e995104fac4c26ada4210092493">More...</a><br/></td></tr>
<tr class="separator:a8b0f7e995104fac4c26ada4210092493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091693f1782225793f93ff9d32061b61"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a091693f1782225793f93ff9d32061b61">getTypeClassStr</a> (const std::string &amp;v=&quot;&quot;)</td></tr>
<tr class="memdesc:a091693f1782225793f93ff9d32061b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the H5 data type of the dataset or given attribute.  <a href="#a091693f1782225793f93ff9d32061b61">More...</a><br/></td></tr>
<tr class="separator:a091693f1782225793f93ff9d32061b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1dee47550ee1f6e24e61358624045c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a8d1dee47550ee1f6e24e61358624045c">getChunkSize</a> ()</td></tr>
<tr class="memdesc:a8d1dee47550ee1f6e24e61358624045c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the storage chunk size of the dataset.  <a href="#a8d1dee47550ee1f6e24e61358624045c">More...</a><br/></td></tr>
<tr class="separator:a8d1dee47550ee1f6e24e61358624045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989f21d7f31e4555d865759db390724"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ac989f21d7f31e4555d865759db390724">getNumBits</a> (const std::string &amp;v=&quot;&quot;)</td></tr>
<tr class="memdesc:ac989f21d7f31e4555d865759db390724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bit used to store each dataset element.  <a href="#ac989f21d7f31e4555d865759db390724">More...</a><br/></td></tr>
<tr class="separator:ac989f21d7f31e4555d865759db390724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2de43661099a7ff83482f7722b5c24"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a8f2de43661099a7ff83482f7722b5c24">toGDAL</a> () const </td></tr>
<tr class="memdesc:a8f2de43661099a7ff83482f7722b5c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate GDALDataset Representation.  <a href="#a8f2de43661099a7ff83482f7722b5c24">More...</a><br/></td></tr>
<tr class="separator:a8f2de43661099a7ff83482f7722b5c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d5fd1d56a17221eeeec5a1edfcbe8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97d5fd1d56a17221eeeec5a1edfcbe8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a97d5fd1d56a17221eeeec5a1edfcbe8e">read</a> (T &amp;v, const std::string &amp;att=&quot;&quot;)</td></tr>
<tr class="memdesc:a97d5fd1d56a17221eeeec5a1edfcbe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading scalar (non string) dataset or attributes.  <a href="#a97d5fd1d56a17221eeeec5a1edfcbe8e">More...</a><br/></td></tr>
<tr class="separator:a97d5fd1d56a17221eeeec5a1edfcbe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5602dddf2b3b92f489e80f9816eb0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#abd5602dddf2b3b92f489e80f9816eb0f">read</a> (std::string &amp;v, const std::string &amp;att=&quot;&quot;)</td></tr>
<tr class="memdesc:abd5602dddf2b3b92f489e80f9816eb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading scalar string dataset or attributes.  <a href="#abd5602dddf2b3b92f489e80f9816eb0f">More...</a><br/></td></tr>
<tr class="separator:abd5602dddf2b3b92f489e80f9816eb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a31a51f2cded612831544831a76bad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1a31a51f2cded612831544831a76bad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ad1a31a51f2cded612831544831a76bad">read</a> (T *buf, const std::string &amp;att)</td></tr>
<tr class="memdesc:ad1a31a51f2cded612831544831a76bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional attribute in raw pointer.  <a href="#ad1a31a51f2cded612831544831a76bad">More...</a><br/></td></tr>
<tr class="separator:ad1a31a51f2cded612831544831a76bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62257d04e828f4ec175633b3c6b9ac1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62257d04e828f4ec175633b3c6b9ac1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a62257d04e828f4ec175633b3c6b9ac1d">read</a> (std::vector&lt; T &gt; &amp;buf, const std::string &amp;att)</td></tr>
<tr class="memdesc:a62257d04e828f4ec175633b3c6b9ac1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional attribute in vector.  <a href="#a62257d04e828f4ec175633b3c6b9ac1d">More...</a><br/></td></tr>
<tr class="separator:a62257d04e828f4ec175633b3c6b9ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bef0f9b4292fe682cdeefcefcdb003"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29bef0f9b4292fe682cdeefcefcdb003"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a29bef0f9b4292fe682cdeefcefcdb003">read</a> (std::valarray&lt; T &gt; &amp;buf, const std::string &amp;att)</td></tr>
<tr class="memdesc:a29bef0f9b4292fe682cdeefcefcdb003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional attribute in valarray.  <a href="#a29bef0f9b4292fe682cdeefcefcdb003">More...</a><br/></td></tr>
<tr class="separator:a29bef0f9b4292fe682cdeefcefcdb003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511c6ff70bcafd8712b29108e3c759d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a511c6ff70bcafd8712b29108e3c759d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a511c6ff70bcafd8712b29108e3c759d4">read</a> (T *buf, const int *startIn=nullptr, const int *countIn=nullptr, const int *strideIn=nullptr)</td></tr>
<tr class="memdesc:a511c6ff70bcafd8712b29108e3c759d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in raw pointer.  <a href="#a511c6ff70bcafd8712b29108e3c759d4">More...</a><br/></td></tr>
<tr class="separator:a511c6ff70bcafd8712b29108e3c759d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c03276b8b46ef111091466cc1291b3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c03276b8b46ef111091466cc1291b3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a5c03276b8b46ef111091466cc1291b3b">read</a> (T *buf, const std::vector&lt; std::slice &gt; *slicesIn)</td></tr>
<tr class="memdesc:a5c03276b8b46ef111091466cc1291b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in raw pointer with std:slice subsetting.  <a href="#a5c03276b8b46ef111091466cc1291b3b">More...</a><br/></td></tr>
<tr class="separator:a5c03276b8b46ef111091466cc1291b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fd42831aa68464a16ae47d944faa3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49fd42831aa68464a16ae47d944faa3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a49fd42831aa68464a16ae47d944faa3b">read</a> (T *buf, const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:a49fd42831aa68464a16ae47d944faa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in raw pointer with std:gslice subsetting.  <a href="#a49fd42831aa68464a16ae47d944faa3b">More...</a><br/></td></tr>
<tr class="separator:a49fd42831aa68464a16ae47d944faa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbec7b6c9bb0c969c3186a94098c8fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cbec7b6c9bb0c969c3186a94098c8fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a3cbec7b6c9bb0c969c3186a94098c8fa">read</a> (std::vector&lt; T &gt; &amp;buf)</td></tr>
<tr class="memdesc:a3cbec7b6c9bb0c969c3186a94098c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in std::vector.  <a href="#a3cbec7b6c9bb0c969c3186a94098c8fa">More...</a><br/></td></tr>
<tr class="separator:a3cbec7b6c9bb0c969c3186a94098c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c80850699e76bfae146da61df499452"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c80850699e76bfae146da61df499452"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a2c80850699e76bfae146da61df499452">read</a> (std::vector&lt; T &gt; &amp;buf, const std::vector&lt; int &gt; *startIn, const std::vector&lt; int &gt; *countIn, const std::vector&lt; int &gt; *strideIn)</td></tr>
<tr class="memdesc:a2c80850699e76bfae146da61df499452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in vector.  <a href="#a2c80850699e76bfae146da61df499452">More...</a><br/></td></tr>
<tr class="separator:a2c80850699e76bfae146da61df499452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbab9d07c805afd7b9d642ae89225383"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbab9d07c805afd7b9d642ae89225383"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#acbab9d07c805afd7b9d642ae89225383">read</a> (std::vector&lt; T &gt; &amp;buf, const std::vector&lt; std::slice &gt; *slicesIn)</td></tr>
<tr class="memdesc:acbab9d07c805afd7b9d642ae89225383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in vector with std:slice subsetting.  <a href="#acbab9d07c805afd7b9d642ae89225383">More...</a><br/></td></tr>
<tr class="separator:acbab9d07c805afd7b9d642ae89225383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27007f7af90100850ee232c808c6800"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa27007f7af90100850ee232c808c6800"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#aa27007f7af90100850ee232c808c6800">read</a> (std::vector&lt; T &gt; &amp;buf, const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:aa27007f7af90100850ee232c808c6800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in vector with std:gslice subsetting.  <a href="#aa27007f7af90100850ee232c808c6800">More...</a><br/></td></tr>
<tr class="separator:aa27007f7af90100850ee232c808c6800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eba2bda6db5e9f44d7066fabb113a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11eba2bda6db5e9f44d7066fabb113a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a11eba2bda6db5e9f44d7066fabb113a1">read</a> (std::valarray&lt; T &gt; &amp;buf)</td></tr>
<tr class="memdesc:a11eba2bda6db5e9f44d7066fabb113a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in valarray.  <a href="#a11eba2bda6db5e9f44d7066fabb113a1">More...</a><br/></td></tr>
<tr class="separator:a11eba2bda6db5e9f44d7066fabb113a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8b87ce472bfbcbe5df407ec7789eba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad8b87ce472bfbcbe5df407ec7789eba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#aad8b87ce472bfbcbe5df407ec7789eba">read</a> (std::valarray&lt; T &gt; &amp;buf, const std::valarray&lt; int &gt; *startIn, const std::valarray&lt; int &gt; *countIn, const std::valarray&lt; int &gt; *strideIn)</td></tr>
<tr class="memdesc:aad8b87ce472bfbcbe5df407ec7789eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in valarray.  <a href="#aad8b87ce472bfbcbe5df407ec7789eba">More...</a><br/></td></tr>
<tr class="separator:aad8b87ce472bfbcbe5df407ec7789eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80303556a4b930d3b61903c2462534f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af80303556a4b930d3b61903c2462534f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#af80303556a4b930d3b61903c2462534f">read</a> (std::valarray&lt; T &gt; &amp;buf, const std::vector&lt; std::slice &gt; *slicesIn)</td></tr>
<tr class="memdesc:af80303556a4b930d3b61903c2462534f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in valarray with std:slice subsetting.  <a href="#af80303556a4b930d3b61903c2462534f">More...</a><br/></td></tr>
<tr class="separator:af80303556a4b930d3b61903c2462534f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45a0945ac58c7cf129c4c92c6903f7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab45a0945ac58c7cf129c4c92c6903f7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ab45a0945ac58c7cf129c4c92c6903f7a">read</a> (std::valarray&lt; T &gt; &amp;buf, const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:ab45a0945ac58c7cf129c4c92c6903f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reading multi-dimensional dataset in valarray with std:slice subsetting.  <a href="#ab45a0945ac58c7cf129c4c92c6903f7a">More...</a><br/></td></tr>
<tr class="separator:ab45a0945ac58c7cf129c4c92c6903f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368fd47d1a912383f015f7f1df881f03"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a368fd47d1a912383f015f7f1df881f03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a368fd47d1a912383f015f7f1df881f03">write</a> (const std::vector&lt; T &gt; &amp;buf)</td></tr>
<tr class="memdesc:a368fd47d1a912383f015f7f1df881f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::vector data into a dataset.  <a href="#a368fd47d1a912383f015f7f1df881f03">More...</a><br/></td></tr>
<tr class="separator:a368fd47d1a912383f015f7f1df881f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e12a4d53480022a1eb3638a1937b9b"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t S&gt; </td></tr>
<tr class="memitem:a49e12a4d53480022a1eb3638a1937b9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a49e12a4d53480022a1eb3638a1937b9b">write</a> (const std::vector&lt; T &gt; &amp;buf, const std::array&lt; int, S &gt; &amp;startIn, const std::array&lt; int, S &gt; &amp;countIn, const std::array&lt; int, S &gt; &amp;strideIn)</td></tr>
<tr class="memdesc:a49e12a4d53480022a1eb3638a1937b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::vector data into a multi-dimensional dataset using std::array for subsetting.  <a href="#a49e12a4d53480022a1eb3638a1937b9b">More...</a><br/></td></tr>
<tr class="separator:a49e12a4d53480022a1eb3638a1937b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6275d0b75c27dc9e0de924b8effed1ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6275d0b75c27dc9e0de924b8effed1ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a6275d0b75c27dc9e0de924b8effed1ad">write</a> (const std::vector&lt; T &gt; &amp;buf, const std::vector&lt; std::slice &gt; *slicesIn)</td></tr>
<tr class="memdesc:a6275d0b75c27dc9e0de924b8effed1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::vector data into a multi-dimensional dataset using std::slice for subsetting.  <a href="#a6275d0b75c27dc9e0de924b8effed1ad">More...</a><br/></td></tr>
<tr class="separator:a6275d0b75c27dc9e0de924b8effed1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebf61a40c115659584cda5b99281f50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ebf61a40c115659584cda5b99281f50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a8ebf61a40c115659584cda5b99281f50">write</a> (const std::vector&lt; T &gt; &amp;buf, const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:a8ebf61a40c115659584cda5b99281f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::vector data into a multi-dimensional dataset using std::gslice for subsetting.  <a href="#a8ebf61a40c115659584cda5b99281f50">More...</a><br/></td></tr>
<tr class="separator:a8ebf61a40c115659584cda5b99281f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c319a6b9fe5978a1bbdd076a9a48cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91c319a6b9fe5978a1bbdd076a9a48cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a91c319a6b9fe5978a1bbdd076a9a48cd">write</a> (const std::valarray&lt; T &gt; &amp;buf)</td></tr>
<tr class="memdesc:a91c319a6b9fe5978a1bbdd076a9a48cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::valarray data into a dataset.  <a href="#a91c319a6b9fe5978a1bbdd076a9a48cd">More...</a><br/></td></tr>
<tr class="separator:a91c319a6b9fe5978a1bbdd076a9a48cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ece03e54276d3c110c6715ddf8e808"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t S&gt; </td></tr>
<tr class="memitem:a84ece03e54276d3c110c6715ddf8e808"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a84ece03e54276d3c110c6715ddf8e808">write</a> (const std::valarray&lt; T &gt; &amp;buf, const std::array&lt; int, S &gt; &amp;startIn, const std::array&lt; int, S &gt; &amp;countIn, const std::array&lt; int, S &gt; &amp;strideIn)</td></tr>
<tr class="memdesc:a84ece03e54276d3c110c6715ddf8e808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::valarray data into a multi-dimensional dataset using std::array for subsetting.  <a href="#a84ece03e54276d3c110c6715ddf8e808">More...</a><br/></td></tr>
<tr class="separator:a84ece03e54276d3c110c6715ddf8e808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae694689f57a437110f9dd1ca2d6d02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ae694689f57a437110f9dd1ca2d6d02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a7ae694689f57a437110f9dd1ca2d6d02">write</a> (const std::valarray&lt; T &gt; &amp;buf, const std::vector&lt; std::slice &gt; *slicesIn)</td></tr>
<tr class="memdesc:a7ae694689f57a437110f9dd1ca2d6d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::valarray data into a multi-dimensional dataset using std::slice for subsetting.  <a href="#a7ae694689f57a437110f9dd1ca2d6d02">More...</a><br/></td></tr>
<tr class="separator:a7ae694689f57a437110f9dd1ca2d6d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade58c3718b65419f2568af8c169b36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adade58c3718b65419f2568af8c169b36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#adade58c3718b65419f2568af8c169b36">write</a> (const std::valarray&lt; T &gt; &amp;buf, const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:adade58c3718b65419f2568af8c169b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing std::valarray data into a multi-dimensional dataset using std::gslice for subsetting.  <a href="#adade58c3718b65419f2568af8c169b36">More...</a><br/></td></tr>
<tr class="separator:adade58c3718b65419f2568af8c169b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9dbee984f74350ceb37d418a178e37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace9dbee984f74350ceb37d418a178e37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ace9dbee984f74350ceb37d418a178e37">write</a> (const T *buf, const size_t sz)</td></tr>
<tr class="memdesc:ace9dbee984f74350ceb37d418a178e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing a raw pointer buffer into a dataset.  <a href="#ace9dbee984f74350ceb37d418a178e37">More...</a><br/></td></tr>
<tr class="separator:ace9dbee984f74350ceb37d418a178e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc65b9b57d5a7a392b10454027ce2b98"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t S&gt; </td></tr>
<tr class="memitem:afc65b9b57d5a7a392b10454027ce2b98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#afc65b9b57d5a7a392b10454027ce2b98">write</a> (const T *buf, const std::array&lt; int, S &gt; &amp;startIn, const std::array&lt; int, S &gt; &amp;countIn, const std::array&lt; int, S &gt; &amp;strideIn)</td></tr>
<tr class="memdesc:afc65b9b57d5a7a392b10454027ce2b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing a raw pointer into a multi-dimensional dataset using std::array for subsetting.  <a href="#afc65b9b57d5a7a392b10454027ce2b98">More...</a><br/></td></tr>
<tr class="separator:afc65b9b57d5a7a392b10454027ce2b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0b2a51e36494ec6bdc3fa657d90dc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b0b2a51e36494ec6bdc3fa657d90dc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a3b0b2a51e36494ec6bdc3fa657d90dc4">write</a> (const T *buf, const std::vector&lt; std::slice &gt; *slicesIn)</td></tr>
<tr class="memdesc:a3b0b2a51e36494ec6bdc3fa657d90dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing a buffer into a multi-dimensional dataset using std::slice for subsetting.  <a href="#a3b0b2a51e36494ec6bdc3fa657d90dc4">More...</a><br/></td></tr>
<tr class="separator:a3b0b2a51e36494ec6bdc3fa657d90dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958794a562bdd2e4c62ccd0b9f355722"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a958794a562bdd2e4c62ccd0b9f355722"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a958794a562bdd2e4c62ccd0b9f355722">write</a> (const T *buf, const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:a958794a562bdd2e4c62ccd0b9f355722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing a buffer into a multi-dimensional dataset using std::gslice for subsetting.  <a href="#a958794a562bdd2e4c62ccd0b9f355722">More...</a><br/></td></tr>
<tr class="separator:a958794a562bdd2e4c62ccd0b9f355722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffb331cca94a7b47ae80aa418b21bd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abffb331cca94a7b47ae80aa418b21bd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#abffb331cca94a7b47ae80aa418b21bd7">createAttribute</a> (const std::string &amp;name, const T &amp;data)</td></tr>
<tr class="memdesc:abffb331cca94a7b47ae80aa418b21bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating and writing a scalar as an attribute.  <a href="#abffb331cca94a7b47ae80aa418b21bd7">More...</a><br/></td></tr>
<tr class="separator:abffb331cca94a7b47ae80aa418b21bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f88b63243256e23a059cedafe0e973"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32f88b63243256e23a059cedafe0e973"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a32f88b63243256e23a059cedafe0e973">createAttribute</a> (const std::string &amp;name, const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a32f88b63243256e23a059cedafe0e973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating and writing a std::vector data as a 1D-array attribute.  <a href="#a32f88b63243256e23a059cedafe0e973">More...</a><br/></td></tr>
<tr class="separator:a32f88b63243256e23a059cedafe0e973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddc3ff5766eaff8b19050a856f5ab9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afddc3ff5766eaff8b19050a856f5ab9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#afddc3ff5766eaff8b19050a856f5ab9b">createAttribute</a> (const std::string &amp;name, const std::valarray&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:afddc3ff5766eaff8b19050a856f5ab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating and writing a std::valarray data as a 1D-array attribute.  <a href="#afddc3ff5766eaff8b19050a856f5ab9b">More...</a><br/></td></tr>
<tr class="separator:afddc3ff5766eaff8b19050a856f5ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04837d0f638784d9148d3ac77d52665"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , size_t S&gt; </td></tr>
<tr class="memitem:aa04837d0f638784d9148d3ac77d52665"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#aa04837d0f638784d9148d3ac77d52665">createAttribute</a> (const std::string &amp;name, const std::array&lt; T2, S &gt; &amp;dims, const std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:aa04837d0f638784d9148d3ac77d52665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating and writing a std::vector data with dimensions (std::array) as an attribute.  <a href="#aa04837d0f638784d9148d3ac77d52665">More...</a><br/></td></tr>
<tr class="separator:aa04837d0f638784d9148d3ac77d52665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd401af31a77defa25b1981da63a7c37"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , size_t S&gt; </td></tr>
<tr class="memitem:abd401af31a77defa25b1981da63a7c37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#abd401af31a77defa25b1981da63a7c37">createAttribute</a> (const std::string &amp;name, const std::array&lt; T2, S &gt; &amp;dims, const std::valarray&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:abd401af31a77defa25b1981da63a7c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating and writing a std::valarray data with dimensions (std::array) as an attribute.  <a href="#abd401af31a77defa25b1981da63a7c37">More...</a><br/></td></tr>
<tr class="separator:abd401af31a77defa25b1981da63a7c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6432e1e729d0b8d0f69e81f92d20e94"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , size_t S&gt; </td></tr>
<tr class="memitem:ae6432e1e729d0b8d0f69e81f92d20e94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ae6432e1e729d0b8d0f69e81f92d20e94">createAttribute</a> (const std::string &amp;name, const std::array&lt; T2, S &gt; &amp;dims, const T *buffer)</td></tr>
<tr class="memdesc:ae6432e1e729d0b8d0f69e81f92d20e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating and writing a raw pointer with dimensions (std::array) to data as an attribute.  <a href="#ae6432e1e729d0b8d0f69e81f92d20e94">More...</a><br/></td></tr>
<tr class="separator:ae6432e1e729d0b8d0f69e81f92d20e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16531b3c797a7a0bfd678f5ad517376c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16531b3c797a7a0bfd678f5ad517376c"></a>
H5::DataSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a16531b3c797a7a0bfd678f5ad517376c">getDataSpace</a> (const int *startIn, const int *countIn, const int *strideIn)</td></tr>
<tr class="memdesc:a16531b3c797a7a0bfd678f5ad517376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DataSpace corresponding to slice defined by start, count and stride. <br/></td></tr>
<tr class="separator:a16531b3c797a7a0bfd678f5ad517376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7683b51d34d716e9260433fef8562e76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7683b51d34d716e9260433fef8562e76"></a>
H5::DataSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a7683b51d34d716e9260433fef8562e76">getDataSpace</a> (const std::vector&lt; std::slice &gt; *sliceIn)</td></tr>
<tr class="memdesc:a7683b51d34d716e9260433fef8562e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DataSpace corresponding to slice defined by a vector of slices. <br/></td></tr>
<tr class="separator:a7683b51d34d716e9260433fef8562e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591f91e09ea80712af569e017ced83eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a591f91e09ea80712af569e017ced83eb"></a>
H5::DataSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a591f91e09ea80712af569e017ced83eb">getDataSpace</a> (const std::gslice *gsliceIn)</td></tr>
<tr class="memdesc:a591f91e09ea80712af569e017ced83eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DataSpace corresponding to a gslice. <br/></td></tr>
<tr class="separator:a591f91e09ea80712af569e017ced83eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c083841c39cf7cbe3d62d41946dcf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06c083841c39cf7cbe3d62d41946dcf0"></a>
H5::DataSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a06c083841c39cf7cbe3d62d41946dcf0">getDataSpace</a> (const size_t xidx, const size_t yidx, const size_t iowidth, const size_t iolength, const size_t band)</td></tr>
<tr class="memdesc:a06c083841c39cf7cbe3d62d41946dcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DataSpace with a GDAL RasterIO-like interface. <br/></td></tr>
<tr class="separator:a06c083841c39cf7cbe3d62d41946dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68a7f34bf075513873c4d1077faa9bf"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad68a7f34bf075513873c4d1077faa9bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#ad68a7f34bf075513873c4d1077faa9bf">write</a> (const std::string *buf, const H5::DataSpace &amp;dspace)</td></tr>
<tr class="separator:ad68a7f34bf075513873c4d1077faa9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d77e8de0d3efbb90924d85440b858e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa0d77e8de0d3efbb90924d85440b858e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#aa0d77e8de0d3efbb90924d85440b858e">createAttribute</a> (const std::string &amp;name, const H5::DataType &amp;datatype, const H5::DataSpace &amp;dataspace, const std::string *buffer)</td></tr>
<tr class="separator:aa0d77e8de0d3efbb90924d85440b858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65031eac7bd8cfa4f674fe7f91ff4711"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a65031eac7bd8cfa4f674fe7f91ff4711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classisce3_1_1io_1_1IDataSet.html#a65031eac7bd8cfa4f674fe7f91ff4711">createAttribute</a> (const std::string &amp;name, const std::string &amp;data)</td></tr>
<tr class="separator:a65031eac7bd8cfa4f674fe7f91ff4711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Our derived dataset structure that includes utility functions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abffb331cca94a7b47ae80aa418b21bd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating and writing a scalar as an attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Reference to scalar attribute value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32f88b63243256e23a059cedafe0e973"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating and writing a std::vector data as a 1D-array attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>std::vector of attribute data to write</td></tr>
  </table>
  </dd>
</dl>
<p>The shape of the attribute is 1D. </p>

</div>
</div>
<a class="anchor" id="afddc3ff5766eaff8b19050a856f5ab9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating and writing a std::valarray data as a 1D-array attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>std::valarray of attribute data to write</td></tr>
  </table>
  </dd>
</dl>
<p>The shape of the attribute is 1D. </p>

</div>
</div>
<a class="anchor" id="aa04837d0f638784d9148d3ac77d52665"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating and writing a std::vector data with dimensions (std::array) as an attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Array containing the size of each dimension of the attribute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>std::vector of attribute data to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd401af31a77defa25b1981da63a7c37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating and writing a std::valarray data with dimensions (std::array) as an attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Array containing the size of each dimension of the attribute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>std::valarray of attribute data to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6432e1e729d0b8d0f69e81f92d20e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T2, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creating and writing a raw pointer with dimensions (std::array) to data as an attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>Array containing the size of each dimension of the attribute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Raw pointer buffer to attribute data to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0d77e8de0d3efbb90924d85440b858e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const H5::DataType &amp;&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const H5::DataSpace &amp;&#160;</td>
          <td class="paramname"><em>dataspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the dataset attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>H5 data type of the attribute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataspace</td><td>H5 data space of the attribute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>of std::string values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65031eac7bd8cfa4f674fe7f91ff4711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::createAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the attribute to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>String scalar attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9d21df7bb99115334d350b8d6b1f815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; isce3::io::IDataSet::getAttrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of attributes attached to dataset. </p>
<p>Return the names of all the attributes attached to the current dataset.</p>

</div>
</div>
<a class="anchor" id="a8d1dee47550ee1f6e24e61358624045c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; isce3::io::IDataSet::getChunkSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the storage chunk size of the dataset. </p>
<p>Return the chunk size of the dataset storage layout.</p>
<p>The size of the returned vector is the same as the rank of the dataset and contains the size of the chunk in each dimensions. A size of 0 means no chunking in that dimension. </p>

</div>
</div>
<a class="anchor" id="a8b0f7e995104fac4c26ada4210092493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; isce3::io::IDataSet::getDimensions </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of each dimension of the dataset or given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Name of the attribute (optional). Returns a std::vector containing the number of elements in each dimension of the dataset or attribute.</td></tr>
  </table>
  </dd>
</dl>
<p>If input is not empty, returns the number of elements in each dimension of the given attribute. If input is empty, returns the number of elements in each dimension of the current dataset. A scalar dataset/attribute will return an empty std::vector. </p>

</div>
</div>
<a class="anchor" id="ac989f21d7f31e4555d865759db390724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isce3::io::IDataSet::getNumBits </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bit used to store each dataset element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Name of the attribute (optional). Returns the actual number of bit used to store the current dataset or given attribute data in the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a988b34554751329f497038d7465320fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isce3::io::IDataSet::getNumElements </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of elements contained in dataset or given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Name of the attribute (optional). Returns the number of elements in the dataset or attribute.</td></tr>
  </table>
  </dd>
</dl>
<p>If input is not empty, returns the number of elements in the given attribute. If input is empty, returns the number of elements in the current dataset. </p>

</div>
</div>
<a class="anchor" id="aae842fcf66ce0b8ab77b406fc861a363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isce3::io::IDataSet::getRank </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of dimension of dataset or given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Name of the attribute (optional). Returns the number of dimension of the dataset or attribute.</td></tr>
  </table>
  </dd>
</dl>
<p>If input is not empty, returns the number of dimension of the given attribute name. If input is empty, returns the number of dimension of current dataset. Scalar:0; 1D array:1, 2D array:2, etc. </p>

</div>
</div>
<a class="anchor" id="a091693f1782225793f93ff9d32061b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string isce3::io::IDataSet::getTypeClassStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the H5 data type of the dataset or given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Name of the attribute (optional). Returns the HDF5 class type of the data contained in the dataset or attribute.</td></tr>
  </table>
  </dd>
</dl>
<p>If input is not empty, returns the class type of the given attribute. If input is empty, returns the class type. This information is useful to provide the HDF% Read function with a container of the proper type. The HFD5 library will do type conversion when possible, but will throw an error if types are incompatible. </p>

</div>
</div>
<a class="anchor" id="a97d5fd1d56a17221eeeec5a1edfcbe8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>att</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading scalar (non string) dataset or attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">att</td><td>Name of the attribute (optional). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Dataset or attribute scalar value.</td></tr>
  </table>
  </dd>
</dl>
<p>If input is not empty, reads the attributes value, otherwise, reads the dataset scalar value. For dataset/attributes containing more than one elements, see other function signature. </p>

</div>
</div>
<a class="anchor" id="abd5602dddf2b3b92f489e80f9816eb0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>att</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reading scalar string dataset or attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">att</td><td>Name of the attribute (optional). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Dataset or attribute string value.</td></tr>
  </table>
  </dd>
</dl>
<p>If input is not empty, reads the attributes string value, otherwise, reads the dataset scalar string value. For dataset/attributes containing more than one elements, see other function signature. </p>

</div>
</div>
<a class="anchor" id="ad1a31a51f2cded612831544831a76bad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>att</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional attribute in raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">att</td><td>String containing the name of the attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Raw pointer to array that will received the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>buffer has to be adequately allocated by caller. </p>

</div>
</div>
<a class="anchor" id="a62257d04e828f4ec175633b3c6b9ac1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>att</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional attribute in vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">att</td><td>String containing the name of the attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::vector will received the attribute data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="a29bef0f9b4292fe682cdeefcefcdb003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>att</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional attribute in valarray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">att</td><td>String containing the name of the attribute to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::valarray will received the attribute data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="a511c6ff70bcafd8712b29108e3c759d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>start</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>count</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>stride</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Raw pointer to array containing the read start location in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Raw pointer to array containing the number of elements to read in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>Raw pointer to array containing the reading stride in each dimension. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Raw pointer to array that will received the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>buffer has to be adequately allocated by caller. start, count, stride must have a number of elements equals to the rank of the dataset. If start is nullptr, reading start location in each dimension is 0. If count is nullptr, full number of element in each dimension is read. If stride is nullptr, stride defaults to 1 in each dimension.</p>
<p>Examples: Dataset contains a 3-bands raster. Dimensions are (100,100,3).</p>
<p>To retrieve the full second band: start=[0,0,1], count=[100,100,1], stride=nullptr or [1,1,1].</p>
<p>To retrieve the first band, but only every other elements in X direction: start=[0,0,0], count=[50,100,1], stride=[2,1,1]. </p>

</div>
</div>
<a class="anchor" id="a5c03276b8b46ef111091466cc1291b3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::slice &gt; *&#160;</td>
          <td class="paramname"><em>slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in raw pointer with std:slice subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slices</td><td>Vector containing an std::slice for each dimension of the dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Raw pointer to array that will received the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>buffer has to be adequately allocated by caller. </p>

</div>
</div>
<a class="anchor" id="a49fd42831aa68464a16ae47d944faa3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::gslice *&#160;</td>
          <td class="paramname"><em>gsliceIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in raw pointer with std:gslice subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gsliceIn</td><td>std::gslice for subsetting </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Raw pointer to array that will received the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>buffer has to be adequately allocated by caller. </p>

</div>
</div>
<a class="anchor" id="a3cbec7b6c9bb0c969c3186a94098c8fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::vector that will receive the full dataset.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="a2c80850699e76bfae146da61df499452"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>std::vector containing the read start location in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>std::vector containing the number of elements to read in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>std::vector containing the reading stride in each dimension. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::vector that will received the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. both case the data read is stored at the beginning of the container.</p>
<p>start, count, stride must have a number of elements equals to the rank of the dataset. If start is nullptr, reading start location in each dimension is 0. If count is nullptr, full number of element in each dimension is read. If stride is nullptr, stride defaults to 1 in each dimension. </p>

</div>
</div>
<a class="anchor" id="acbab9d07c805afd7b9d642ae89225383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::slice &gt; *&#160;</td>
          <td class="paramname"><em>slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in vector with std:slice subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slices</td><td>Vector containing an std::slice for each dimension of the dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::vector that will receive the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="aa27007f7af90100850ee232c808c6800"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::gslice *&#160;</td>
          <td class="paramname"><em>gsliceIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in vector with std:gslice subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gsliceIn</td><td>std::gslice for subsetting </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::vector that will receive the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="a11eba2bda6db5e9f44d7066fabb113a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in valarray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::valarray that will receive the full dataset.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="aad8b87ce472bfbcbe5df407ec7789eba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::valarray&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::valarray&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::valarray&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in valarray. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startIn</td><td>std::valarray containing the read start location in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countIn</td><td>std::valarray containing the number of elements to read in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideIn</td><td>std::valarray containing the reading stride in each dimension. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::valarray that will received the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container.</p>
<p>startIn, countIn, strideIn must have a number of elements equals to the rank of the dataset. If startIn is nullptr, reading start location in each dimension is 0. If countIn is nullptr, full number of element in each dimension is read. If strideIn is nullptr, stride defaults to 1 in each dimension. </p>

</div>
</div>
<a class="anchor" id="af80303556a4b930d3b61903c2462534f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::slice &gt; *&#160;</td>
          <td class="paramname"><em>slicesIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in valarray with std:slice subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sliceIn</td><td>sts::valarray containing an std::slice for each dimension of the dataset </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::valarray that will receive the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="ab45a0945ac58c7cf129c4c92c6903f7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::read </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::gslice *&#160;</td>
          <td class="paramname"><em>gsliceIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reading multi-dimensional dataset in valarray with std:slice subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gsliceIn</td><td>std::gslice for subsetting </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>std::valarray that will receive the read data.</td></tr>
  </table>
  </dd>
</dl>
<p>If the output container is undersized compared to the data to read the function will size it accordingly. If the container is larger than the data to be read, its size is unchanged. In both case the data read is stored at the beginning of the container. </p>

</div>
</div>
<a class="anchor" id="a8f2de43661099a7ff83482f7722b5c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string isce3::io::IDataSet::toGDAL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate GDALDataset Representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">str</td><td>String representation for GDAL's <a class="el" href="classisce3_1_1io_1_1IH5Dataset.html" title="IH5 interface to GDAL Dataset to allow read/write to HDF5 datasets from ISCE. ">IH5Dataset</a> driver</td></tr>
  </table>
  </dd>
</dl>
<p>Returns IH5:::ID=string </p>

</div>
</div>
<a class="anchor" id="a368fd47d1a912383f015f7f1df881f03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::vector data into a dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::vector of data to write to dataset. It is mandatory that the size of the dataset and the number of elements in the vector matches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49e12a4d53480022a1eb3638a1937b9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::vector data into a multi-dimensional dataset using std::array for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::vector of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>std::array containing the write start location in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>std::array containing the number of elements to write in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>std::array containing the writing stride in each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6275d0b75c27dc9e0de924b8effed1ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::slice &gt; *&#160;</td>
          <td class="paramname"><em>slicesIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::vector data into a multi-dimensional dataset using std::slice for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::vector of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sliceIn</td><td>std::vector containing an std::slice for each dimension of the dataset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ebf61a40c115659584cda5b99281f50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::gslice *&#160;</td>
          <td class="paramname"><em>gsliceIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::vector data into a multi-dimensional dataset using std::gslice for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::vector of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gsliceIn</td><td>std::gslice for subsetting the dataset writing location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91c319a6b9fe5978a1bbdd076a9a48cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::valarray data into a dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::valarray of data to write to dataset. It is mandatory that the size of the dataset and the number of elements in the valarray matches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84ece03e54276d3c110c6715ddf8e808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>countIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>strideIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::valarray data into a multi-dimensional dataset using std::array for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::valarray of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIn</td><td>std::array containing the write start location in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countIn</td><td>std::array containing the number of elements to write in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideIn</td><td>std::array containing the writing stride in each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ae694689f57a437110f9dd1ca2d6d02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::slice &gt; *&#160;</td>
          <td class="paramname"><em>slicesIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::valarray data into a multi-dimensional dataset using std::slice for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::valarray of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sliceIn</td><td>std::vector containing an std::slice for each dimension of the dataset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adade58c3718b65419f2568af8c169b36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::gslice *&#160;</td>
          <td class="paramname"><em>gsliceIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing std::valarray data into a multi-dimensional dataset using std::gslice for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>std::valarray of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gsliceIn</td><td>std::gslice for subsetting the dataset writing location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace9dbee984f74350ceb37d418a178e37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing a raw pointer buffer into a dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Raw pointer to buffer of data to write to dataset. The size of the dataset and the number of elements in the buffer must match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc65b9b57d5a7a392b10454027ce2b98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>startIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>countIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; int, S &gt; &amp;&#160;</td>
          <td class="paramname"><em>strideIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing a raw pointer into a multi-dimensional dataset using std::array for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>raw pointer to a buffer of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIn</td><td>std::array containing the write start location in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">countIn</td><td>std::array containing the number of elements to write in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideIn</td><td>std::array containing the writing stride in each dimension.</td></tr>
  </table>
  </dd>
</dl>
<p>It the responsability of the caller to make sure that the size of the buffer inferred from the startIn/countIn/strideIn matches the actual size of the buffer. </p>

</div>
</div>
<a class="anchor" id="a3b0b2a51e36494ec6bdc3fa657d90dc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::slice &gt; *&#160;</td>
          <td class="paramname"><em>slicesIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing a buffer into a multi-dimensional dataset using std::slice for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>raw pointer to a buffer of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sliceIn</td><td>std::vector containing an std::slice for each dimension of the dataset</td></tr>
  </table>
  </dd>
</dl>
<p>It the responsability of the caller to make sure that the size of the buffer inferred from the startIn/countIn/strideIn matches the actual size of the buffer. </p>

</div>
</div>
<a class="anchor" id="a958794a562bdd2e4c62ccd0b9f355722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::gslice *&#160;</td>
          <td class="paramname"><em>gsliceIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writing a buffer into a multi-dimensional dataset using std::gslice for subsetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>raw pointer to a buffer of data to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gsliceIn</td><td>std::gslice for subsetting the dataset writing location</td></tr>
  </table>
  </dd>
</dl>
<p>It the responsability of the caller to make sure that the size of the buffer inferred from the startIn/countIn/strideIn matches the actual size of the buffer. </p>

</div>
</div>
<a class="anchor" id="ad68a7f34bf075513873c4d1077faa9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isce3::io::IDataSet::write </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const H5::DataSpace &amp;&#160;</td>
          <td class="paramname"><em>dspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to std::string buffer to write to dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">DataSpace</td><td>object for locating where to write the data in the dataset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>isce/cxx/isce3/io/<a class="el" href="IH5_8h_source.html">IH5.h</a></li>
<li>isce/cxx/isce3/io/IH5.cpp</li>
<li>isce/cxx/isce3/io/IH5.icc</li>
</ul>
</div><!-- contents -->
<hr>
Generated for ISCE3.0 by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.5.
</body>
</html>
