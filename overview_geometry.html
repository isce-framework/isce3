<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ISCE: Radar Geometry Handling in ISCE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ISCE
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Radar Geometry Handling in ISCE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#geomdefn">Imaging Geometry and Definitions</a><ul><li class="level2"><a href="#geomnative">Native Doppler Geometry</a></li>
<li class="level2"><a href="#geomzero">Zero Doppler Geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#forwardgeom">Forward transformation - Radar geometry to Map coordinates</a><ul><li class="level2"><a href="#localTCN">Step 1: Set up local Geocentric spherical coordinate system</a></li>
<li class="level2"><a href="#rangedopeqn">Step 2: Range Doppler Equation Solution</a></li>
<li class="level2"><a href="#deminterp">Step 3: DEM interpolation</a></li>
</ul>
</li>
<li class="level1"><a href="#inversegeom">Inverse transformation - Map coordinates to Radar geometry</a><ul><li class="level2"><a href="#orbitinterp">Step 1: Orbit interpolation</a></li>
<li class="level2"><a href="#inversenewton">Step 2: Newton-Raphson iteration</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="geomdefn"></a>
Imaging Geometry and Definitions</h1>
<p>SAR focusing techniques combine information from numerous transmitted pulses to produce a high-resolution two-dimensional backscatter image of the area illuminated by the antenna footprint (see Figure below). Consequently, the observed amplitude and phase measurement at any single pixel in a SAR image cannot be attributed to any individual pulse in azimuth time or range bin in slant range. To better geolocate targets in focused SAR images, most processing approaches use various conventions based on the Range-Doppler equation to set up reference functions for compressing energy in slant range and azimuth time domains.</p>
<div class="image">
<img src="Zerodop_geometry.png" alt="Zerodop_geometry.png"/>
</div>
<p>The Range-Doppler equation establishes the relationship between the Target T located at position ( \(\mathbf{T}\)) and the satellite imaging location:</p>
<p class="formulaDsp">
\[ \frac{2 \cdot \mathbf{V_{sat}}\left( \eta_{f,T} \right) \cdot \left( \mathbf{T} - \mathbf{R_{sat}}\left(\eta_{f,T}\right) \right)}{\lambda \cdot R_{f,T}} = f\left(\eta_{f,T}, R_{f,T}\right) \]
</p>
<p class="formulaDsp">
\[ R_{f,T} = \left|\mathbf{T} - \mathbf{R_{sat}}\left(\eta_{f,T} \right)\right| \]
</p>
<p> where</p>
<ul>
<li>
\(\eta\) represents slow time domain. Also referred to as azimuth time. </li>
<li>
\(R\) represents slant range domain. Directly related to the fast time domain. </li>
<li>
\(f\left(\eta,R\right)\) represents the nominal imaging Doppler model in Hz and is a function of azimuth time and slant range. Note that this may be different from the Doppler centroid of the acquired data. </li>
<li>
\(\eta_{f,T}\) is the Doppler azimuth time position of Target T, under the assumed imaging Doppler model. </li>
<li>
\(R_{f,T}\) is the slant range position of Target T, under the assumed imaging Doppler model. </li>
<li>
\(\eta_{0,T}\) is the zero Doppler azimuth time position of Target T. </li>
<li>
\(R_{0,T}\) is the zero Doppler slant range position of Target T. </li>
<li>
\(\eta_{dc,T}\) is the beam center azimuth time position of Target T. </li>
<li>
\(R_{dc,T}\) is the beam center slant range position of Target T. </li>
</ul>
<p>For a given Doppler frequency model \(f\left(\eta_{f,T},R_{f,T}\right)\), the Target T would show up at azimuth line location \( \eta_{f,T}\) and slant range location \(R_{f,T}\) in the focused image. Note that the choice of Doppler frequency model to describe the geometry of the SAR image can be arbitrary. However, there are two standard conventions widely used for easy interpretation of the imaging geometry: Native Doppler (or Beam Center) geometry and the Zero Doppler (or Tangential) geometry. ISCE supports both these conventions.</p>
<h2><a class="anchor" id="geomnative"></a>
Native Doppler Geometry</h2>
<p>The Native Doppler geometry system is the most natural system for representing SAR data. In this case, the Doppler frequency model is chosen to match the estimated Doppler Centroid of the data, i.e.:</p>
<p class="formulaDsp">
\[ \frac{2 \cdot \mathbf{V_{sat}}\left( \eta_{dc,T} \right) \cdot \left( \mathbf{T} - \mathbf{R_{sat}}\left(\eta_{dc,T}\right) \right)}{\lambda \cdot R_{dc,T}} = f\left(\eta_{dc,T}, R_{dc,T}\right) \]
</p>
<p>The Doppler Centroid at a given azimuth time and slant range determines the imaging geometry as well as the azimuth carrier on the data. The azimuth time and slant range correspond to the targetâ€™s passage through the center of the antenna along track footprint. The Native Doppler convention is ideal for applying antenna pattern and gain corrections. However, the Doppler Centroid of the acquired data can vary in both azimuth time and slant range. Consequently, patch processing of the SAR pulses that accounts for updated processing parameter along-track introduces complications. The dependence on Doppler Centroid also makes it a little more complicated to mosaic acquisitions on the same track that were processed with slightly different processing parameters.</p>
<p>The Native Doppler convention is primarily used by NASA JPL for generating SAR imagery for its airborne missions like UAVSAR. The ALOS PALSAR L1.1 product was also produced in Native Doppler geometry system by JAXA.</p>
<h2><a class="anchor" id="geomzero"></a>
Zero Doppler Geometry</h2>
<p>The Zero Doppler geometry system is the most widely used convention for representing SAR data. In this case, Doppler frequency model is set to zero, i.e.:</p>
<p class="formulaDsp">
\[ \mathbf{V_{sat}}\left( \eta_{0,T} \right) \cdot \left( \mathbf{T} - \mathbf{R_{sat}}\left(\eta_{0,T}\right) \right) = 0 \]
</p>
<p>The imaging geometry can be determined independent of the Doppler Centroid and central frequency of the acquisition. The vector from the satellite to target is perpendicular to the instantaneous satellite velocity. Note that in case of the zero Doppler geometry, the azimuth time corresponding to a target can lie outside the interval defined by the imaging aperture. The SAR data still has an azimuth carrier defined by the Doppler Centroid but this piece of information does not affect the geolocation or interpretation of the imaging geometry. This independence between Doppler Centroid and imaging geometry, allows one to mosaic images on the same track processed with different parameters easily.</p>
<p>The Zero Doppler convention is used by ESA and European sensors like ERS, ENVISAT (<b>[envisat2007product]</b>, <b>[small2008guide]</b>), Sentinel-1 <b>[piantanida2016sentinel]</b> as well as TerraSAR-X and COSMO-SkyMed. The ALOS-2 PALSAR L1.1 product is also produced in Zero Doppler geometry system by JAXA.</p>
<h1><a class="anchor" id="forwardgeom"></a>
Forward transformation - Radar geometry to Map coordinates</h1>
<p>The forward geometry transformation is implemented via <a class="el" href="classisce_1_1geometry_1_1Topo.html" title="Transformer from radar geometry coordinates to map coordinates with DEM / reference altitude...">isce::geometry::Topo</a> module in ISCE.</p>
<p>This algorithm maps a given Target (T) located at azimuth time \( \left( \eta_{dc,T} \right) \) and slant range \(\left( R_{dc,T}\right) \) in radar image coordinates to map coordinates \(\left(X_{map}, Y_{map}, h\left(X_{map}, Y_{map}\right)\right)\). This is done using the given Doppler model \(\left( f_d\left(\eta,R\right)\right)\) and a Digital Elevation Model (DEM) \( \left(z\left( X, Y\right)\right)\) as function of horizontal datum coordinates X, Y. Details of various implementations of the forward mapping algorithm can be found in a number of references (<b>[kropatsch1990generation]</b>, <b>[eineder2003efficient]</b>, <b>[sansosti2006geometrical]</b>, <b>[nitti2011impact]</b>).</p>
<p>The forward mapping problem is formulated as finding target position \(\mathbf{T}\), such that the following two constraints are satisfied</p>
<p class="formulaDsp">
\[ \frac{2 \mathbf{V_{sat}\left(\eta_{dc,T}\right)} \cdot \left( \mathbf{T} - \mathbf{R_{sat}\left(\eta_{dc,T}\right)} \right)}{\lambda \cdot R_{dc,T}} = f_{dc}\left(\eta_{dc,T}, R_{dc,T} \right) \]
</p>
 <p class="formulaDsp">
\[ \left| \mathbf{T} - \mathbf{R_{sat}\left(\eta_{dc,T}\right)} \right | = R_{dc,T} \]
</p>
<p>In ISCE, the algorithm is broken down into 4 steps. Note that all computations are performed in the Earth Centered Earth Fixed (ECEF) coordinates.</p>
<ol>
<li>
<p class="startli">Setting up of a local Geocentric spherical coordinate system at the location of the satellite. Initializing the height of the target above local sphere to a nominal value \(h_p\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Solve the constrained optimization problem shown above for point \(\mathbf{T}\) on the local sphere. Convert the location of the coordinates to map coordinates - \(X_{map}, Y_{map}\). Note that only the horizontal location information is used from this estimate for the next stage of the algorithm.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Interpolate the given DEM \( z\left(X,Y\right) \) to obtain \(z_{map}\). Conver the coordinates \(\left(X_{map}, Y_{map}, z_{map}\right)\) to the local spherical system and estimate the height above the local sphere \(h_{est}\).</p>
<p class="endli"></p>
</li>
<li>
Go back to Step 1, with \(h_0 = h_{est}\). Continue iterating till \(h_{est}\) converges. When the algorithm converges \(\left(X_{map}, Y_{map}, z_{map}\right)\) from the latest iteration represents the target location in map coordinates. </li>
</ol>
<p>Each of the steps is described in detail below. The algorithm can support analysis in both Native Doppler and Zero Doppler coordinate systems. For Zero Doppler coordinate system, the Doppler model \( \left( f_{d}\left(\eta_{dc,T}, R_{dc,T}\right) \right) \) is set to zero.</p>
<h2><a class="anchor" id="localTCN"></a>
Step 1: Set up local Geocentric spherical coordinate system</h2>
<p>Let \(\mathbf{R_{sat}}\) and \(\mathbf{V_{sat}}\) represent the position of the satellite corresponding to the azimuth time of the target of interest. The Geocentric radius at the intersection of the reference Ellipsoid and the vector connecting the satellite position to the center of the Ellipsoid is given by</p>
<p class="formulaDsp">
\[ R_c =\frac{\left| \mathbf{R_{sat}}\right|} {\sqrt{ \left( \frac{X_{sat}}{a_e} \right)^2 + \left( \frac{Y_{sat}}{a_e} \right)^2 + \left( \frac{Z_{sat}}{b_e} \right)^2 }} \]
</p>
<p>Relative height of the satellite along the Geocentric vector is given by</p>
<p class="formulaDsp">
\[ h_{sat} = \left| \mathbf{R_{sat}} \right| - R_c \]
</p>
<p>We can set up a local orthogonal coordinate system on a sphere with radius \(R_c\) at \(\mathbf{R_{sat}}\) as follows:</p>
<p class="formulaDsp">
\[ \hat{n} = -\left[ \frac{X_{sat}}{\left| \mathbf{R_{sat}} \right|}, \frac{Y_{sat}}{\left| \mathbf{R_{sat}} \right|}, \frac{Z_{sat}}{\left| \mathbf{R_{sat}} \right|} \right] \]
</p>
<p class="formulaDsp">
\[ \hat{c} = \frac{\mathbf{V_{sat}} \times \hat{n}}{\left| \mathbf{V_{sat}} \times \hat{n} \right| } \]
</p>
<p class="formulaDsp">
\[ \hat{t} = \hat{c} \times \hat{n} \]
</p>
<p>where </p><ul>
<li>
\(\hat{n}\) represents the unit vector pointing towards the center of the reference Ellipsoid. </li>
<li>
\(\hat{c}\) represents the axis perpendicular to the plane represented by the Geocentric vector and the satellite's velocity vector. </li>
<li>
\(\hat{t}\) represents the tangential component of the velocity vector </li>
</ul>
<h2><a class="anchor" id="rangedopeqn"></a>
Step 2: Range Doppler Equation Solution</h2>
<p>Assuming that the target point is located at height \(h_0\) above the local sphere of radius ( \(R_c\)), the slant range vector of length \(R_0\) can be represented in the local TCN basis as</p>
<p class="formulaDsp">
\[ \mathbf{T} = \mathbf{R_{sat}} + \alpha \cdot \hat{t} + \beta \cdot \hat{c} + \gamma \cdot \hat{n} \]
</p>
<p>Using the law of cosines on the local sphere, we can show that</p>
<p class="formulaDsp">
\[ \gamma = \frac{R_0}{2} \cdot \left[ \left( \frac{h_{sat} + R_c}{R_0}\right) + \left( \frac{R_0}{h_{sat} + R_c } \right) - \left( \frac{h_0 + R_c}{h_{sat}+R_c} \right) \cdot \left( \frac{h_0 + R_{curv}}{R_0} \right) \right] \]
</p>
<p class="formulaDsp">
\[ \alpha = \frac{f_d\left(R_0\right) \cdot \lambda \cdot R_0}{2 \cdot \left| \mathbf{V_{sat}} \right|} - \gamma \cdot \frac{\hat{n} \cdot \hat{v}}{\hat{t} \cdot \hat{v}} \]
</p>
<p>where \(\hat{v} = \frac{\mathbf{V_{sat}}}{\left| \mathbf{V_{sat}} \right|}\) is the unit vector along the satellite velocity.</p>
<p class="formulaDsp">
\[ \beta = -L\cdot \sqrt{R_0^2 - \gamma^2 - \alpha^2} \]
</p>
<p>where \(L=-1\) for right looking imaging geometry and \(L=+1\) for left looking imaging geometry. Once \( \alpha, \beta\) and \(\gamma\) are computd, we can compute the location of the target in Cartesian space \(\left( \mathbf{T} \right)\). The target location can be converted into map coordinates as \(\left( X_{map}, Y_{map}, z_map\left(X_{map}, Y_{map}\right) \right)\) using standard transformations (see <a class="el" href="classisce_1_1core_1_1ProjectionBase.html" title="Abstract base class for individual projections. ">isce::core::ProjectionBase</a>).</p>
<h2><a class="anchor" id="deminterp"></a>
Step 3: DEM interpolation</h2>
<p>DEMs are commonly provided in non-Cartesian coordinates (e.g., Lat-Long grid, UTM grid, EASE-2 grid) and contain heights above a geoid (e.g., EGM96 or EGM08). The geometry mapping algorithms presented in this document explicitly assume that the DEMs have been adjusted to represent heights above the representative ellipsoid like WGS84. Standard GIS tools offer numerous methods of interpolating height data (e.g., nearest neighbor, bilinear, and bicubic). We recommend using biquintic interpolation method <b>[kidner1999s]</b> as this appears to be least susceptible to difference between the DEM resolution and the radar grid resolution to which it is being mapped. Moreover, biquintic polynomials represent the smallest order polynomials that preserve slope information when interpolating across neighboring cells in the DEM.</p>
<p>For the forward mapping algorithm, we interpolate the DEM at location \(\left(X_{map}, Y_{map}\right)\) to determine the new \(z_{map}\). This new target location is then transformed into the ECEF coordinate system and the new height estimate \(h_est\) is given by</p>
<p class="formulaDsp">
\[ h_{est} = \left| \mathbf{T} \right| - R_c \]
</p>
<p>and \(h_{est}\) becomes the initial height estimate \(h_0\) for the next iteration of the algorithm. When trying to estimate the target location on a reference ellipsoid, the DEM is assumed to be of constant height \(z_{map}\) and the algorithm converges in two or three iterations.</p>
<h1><a class="anchor" id="inversegeom"></a>
Inverse transformation - Map coordinates to Radar geometry</h1>
<p>This algorithm maps a given target ( \(\mathbf{T}\)) located at \(\left (X,Y, z\left(X,Y\right)\right)\) in map coordinates represented by horizontal datum \(\left(X,Y\right)\) to radar images coordinates - azimuth time ( \(\eta\)) and slant range ( \(R\)), using a given Doppler model \(\left(f_d \left(\eta,R\right)\right)\). Different implementations of the Inverse Mapping Algorithm can be found in several references (<b>[eineder2003efficient]</b>, <b>[sansosti2006geometrical]</b>, <b>[nitti2011impact]</b>).</p>
<p>The ISCE implementation of the algorithm is based on the simple Newton-Raphson method and has three key steps:</p>
<ol>
<li>
We start with an initial guess for the azimuth time ( \(\eta_g\)) and interpolate the state vectors provided with the radar metadata to estimate the satellite position \(\left( \mathbf{R_{sat}\left( \eta_g\right)} \right)\) and velocity \( \left( \mathbf{V_{sat}\left( \eta_g \right)} \right)\). </li>
<li>
Perform a Newton Raphson iteration to determine the change to be applied to our azimuth time guess ( \(\Delta \eta \)). </li>
<li>
Continue iterations until the change in azimuth time ( \(\Delta \eta\)) is negligible. When the algorithm converges \(\eta_g\) represents the azimuth time and the distance between satellite location at \(\eta_g\) represents the slant range in radar image coordinates. </li>
</ol>
<p>Each of the steps is described in detail below. The algorithm can support analysis in both Native Doppler and Zero Doppler coordinate systems. For Zero Doppler coordinate system, the Doppler model \(\left( f_d\left(\eta_{dc,T}, R_{dc,T}\right)\right)\) is set to zero.</p>
<h2><a class="anchor" id="orbitinterp"></a>
Step 1: Orbit interpolation</h2>
<p>To precisely map targets from map coordinates to radar image coordinaes, we need to be able to interpolate the orbit state vectors with an accuracy on order of few mm. Two possible interpolation methods satisfy this requirement:</p>
<ol>
<li>
<p class="startli"><b>Hermite polynomial interpolation</b><br />
 A third-order Hermite polynomial can be used to interpolate the orbit information reliably. The Hermite polynomial is constructed using 4 state vectors spanning the azimuth time epoch of interest; and combines position and velocity information for interpolating the state vectors <b>[sandwell2008accuracy]</b>. Hermite polynomials works better in the scenario when the available state vectors are sampled less frequently than once every 30 seconds.</p>
<p class="endli"></p>
</li>
<li>
<b>Legendre polynomial interpolation</b><br />
 An eighth-order Legendre polynomial can also be used to interpolate the orbit information reliably. The Legendre polynomial is constructed using 9 state vectors spanning the azimuth time epoch of interest; and interpolates the position and velocity arrays independently of each other <b>[getorbdelft]</b>. This makes it suitable for use with Polar Format Algorithm as well. Legendre polynomial method performs better when the available state vectors are sampled frequently (&lt; 30 secs apart). </li>
</ol>
<p>For most modern SAR sensors, the precise position and velocity vectors in the annotation metadata are consistent with each other and can be reliably interpolated with Hermite polynomials. However, when focusing the L0B data for emergency response, the precise state vectors may not be available. Legendre polynomials are recommended for interpolation of the rapid orbits as it reduces geolocation errors.</p>
<p>At the start of the algorithm, we pick and initial azimuth time ( \(\eta_g\)) as the first guess. Typically, this is set to the center of the azimuth data block / scene that is being processed. After interpolation, we end up with the initial estimate for satellite position \(\left( \mathbf{R_{sat}\left( \eta_g \right)} \right)\) and satellite velocity \(\left( \mathbf{V_{sat}\left( \eta_g \right)} \right)\).</p>
<h2><a class="anchor" id="inversenewton"></a>
Step 2: Newton-Raphson iteration</h2>
<p>The function \(y\left( \eta \right)\), whose zero crossing we are trying to determine using the Newton-Raphson method can be directly derived from the Range Doppler Equation.</p>
<p class="formulaDsp">
\[ y\left( \eta \right) = \mathbf{V_{sat}\left(\eta\right)} \cdot \left( \mathbf{T} - \mathbf{R_{sat}\left( \eta \right)}\right) - \frac{\lambda}{2} \cdot f_d\left( \eta, R_{dc}\left(\eta\right)\right) \cdot R_dc\left( \eta \right) = 0 \]
</p>
<p>where </p><p class="formulaDsp">
\[ R_{dc}\left(\eta \right) = \left| \mathbf{T} - \mathbf{R_{sat}\left(\eta\right)}\right| \]
</p>
<p>The adjustment to the initial guess of the azimuth time epoch ( \(\eta_g\)) is given by </p><p class="formulaDsp">
\[ \eta_{new} = \eta_g - \frac{y\left( \eta_g \right)}{y^{\prime}\left( \eta_g\right)} \]
</p>
<p>where </p><p class="formulaDsp">
\[ y^{\prime}\left( \eta \right) \approx \frac{\lambda}{2} \cdot \left[ \frac{ f_{dc}\left( \eta, R_{dc}\left( \eta \right) \right)}{R_{dc}\left( \eta \right)} + f_d^{\prime}\left( \eta, R_{dc}\left( \eta \right) \right) \right] \cdot \left( \mathbf{V_{sat}\left( \eta \right)} \cdot \left( \mathbf{T} - \mathbf{R_{sat}\left(\eta\right)} \right) - \left| \mathbf{V_{sat}\left( \eta \right)}\right|^2 \right) \]
</p>
<p>The Newton-Raphson iterations are continued till the estimated azimuth time converges, i.e, the Range-Doppler equation is satisfied. When the algorithm converges \(R_{dc}\left( \eta_{new} \right)\) represents the slant range to the target. </p>
</div></div><!-- contents -->
<hr>
Generated for ISCE3.0 by
<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.13.
</body>
</html>
